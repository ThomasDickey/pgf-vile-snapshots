
Getting along with vile						(version 5.5)
-----------------------						-------------

	Use Ctrl-D and Ctrl-U to scroll through this help information.

	Type Ctrl-O to make this the only window on the screen.
	Type Ctrl-K to get rid of this window.

	First, to leave vile, use any of the following:
		:q
		:quit
		:exit
		:wq	(writes current buffer before quitting)
		:q!	(quits without writing any changes!)
		Q
		:wwq or ZZ	(will write all changed buffers)
		^X-^C	(don't know why.  _They_ don't put in ":q" for _us_!
			 Actually, if ^C is your interrupt character, this
			 won't get you out of vile.)

	To get help (probably just this text), use any of:
		:h
		:help
		^X-h
		^A-h

	The only vile commands described herein are those not present in
	vi, or differing greatly from those in vi.  There is a section at
	the bottom describing other differences between vile and vi.

	To get a complete list of all commands, type ":list-commands".  To
	get a list of all commands that contain the string "name", type
	":apropos name".  These lists will show all command synonyms and
	key sequences that are bound to the same function, along with a
	short description of the command, and whether it is a motion or
	operator command.

	To get information on a specific key-binding or function, use the
	"describe-key" or "describe-function" commands.  You will be asked
	for a keystroke or function name, and a short description will be
	shown.

	You needn't type full command names -- type a few characters and
	hit TAB to perform command completion.  Hitting a second TAB will
	pop up a window containing the list of possible completions.

	If your screen hops around a lot when you scroll, see the "Note on
	Scrolling" section near the bottom of this file.

General Remarks
---------------

	vile holds text in "buffers".  Usually, these correspond to a file
	that you are editing, but not always.  For instance, a buffer
	might be used to display this help text, or to hold the output
	of a shell command that you have run.  Buffers have names, and
	these usually match the names of the files they contain.

	Buffers are sometimes displayed in windows.  A buffer may be
	displayed in more than one window at the same time.  There is
	no such thing as a hidden window.  All existing windows are on
	the screen.  There may, however, be hidden buffers, which are not
	currently associated with any window.

	All yank/delete registers (the default unnamed register, the numbered
	registers ("1-"9) that hold line-deletes, and the named registers
	("a-"z)) are global to the editor, and not attached to any single
	buffer.  Thus you can delete text in one buffer and put it back in
	another.

	Undo operations are attached to a buffer, not a window.  Thus if
	you have two windows to the same buffer, and make a change in one,
	you can undo it in the other.

	vile is 8-bit clean, allowing it to be used more easily at non-
	English speaking sites.  See the section on "8-Bit Operation" for
	more information.

Command Prefixes
----------------

	To extend the vi command set in vile, two (or three, depending on
	how you count them) command "prefixes" exist.  These keystrokes,
	in combination with another key, can be bound as a pair to execute
	any vile function.  The default values for these prefixes are
                Key:                    Bound to dummy function:
		^X     Control-X 	cntl_x-prefix
		^A     Control-A 	cntl_a-prefix
		#      poundsign	function-prefix
	If you find any of these keys hard to type, or would prefer that
	they are all control characters (or all non-control), they can
	be changed by binding a new key to the function listed above.  See
	the section on "Key Rebinding" below.  If you do change the values
	of these keys, most of vile's informational displays (the Binding
	List, for instance) will reflect these changes.  This documentation,
	of course, will not change.

	(The '#' key is used in vi to give terminal independent access
	to function key bindings.  This is also true in vile -- if something
	is bound to '#2', then it is also probably available with key F2
	on your keyboard.)

Buffer manipulation commands:
-----------------------------

	vile stores buffers in a sorted list.  Depending on the
	setting of the "autobuffer" mode, this list is either sorted
	in "most-recently-used" order (this is the vile default), or in a
	fixed order dependent on the order of editing (this is how vi
	normally does it, and can be attained by turning "autobuffer"
	off, with "set noautobuffer").

	_	Show a list of the first 9 buffers.  Follow this command
		with a digit to select that buffer, or simply repeat it
		("__") to select the buffer most-recently visited.  In
		autobuffer mode, this is identical to "_1".  If autobuffer
		mode is off, the buffer which will be visited with "__" is
		flagged with a '#' character in the list.  Modified buffers
		are preceded by a '*' in the history list.  There are many
		different ways to get the previous file:
			__
			_1	(autobuffer mode on)
			1_	(    "       "    ")
			:e#
			^^   (ctrl-^)  (but many keyboards can't produce this)

		The buffer number may also precede the '_' command.  This is
		necessary when visiting buffers numbered higher than '9'.  For
		example, one would type "13_" to visit buffer 13 in the list.

		[ See the note under "Differences", below, for comments on
		vi's use of '_'.]

	:e	Edit a file.  If the file is already in a buffer, that buffer
		will be recalled into the current window.  This occurs as
		follows: If the name given contains no path delimiters
		(i.e.  slashes), then it will be compared to the existing
		vile buffer names.  Failing that comparison (or if there
		are any slashes in the name), the name will be stretched
		into an absolute path, and will be compared to the existing
		buffers' filenames.  In either case, the matching buffer
		will be chosen.  If there are no such matches, the file
		will be fetched from the filesystem.  This matching
		technique introduces an ambiguity, since buffer names are
		created from the last path component of filenames.  To
		force vile to edit a file from the current directory whose
		basename matches that of one that was edited elsewhere,
		simply preface the name with "./".  For example, if you
		edit "../Makefile" and later attempt to edit "Makefile",
		vile will assume you are referring to the _buffer_ named
		"Makefile".  To get the file in the current directory,
		specify "./Makefile".

	:e!	Re-edit a file.  A different filename can be given, and the
		buffer name will change to match it.  This command is not as
		necessary in vile as it is in vi, since multiple buffers may
		have outstanding unwritten changes.

	:n	Go to the next buffer.  "Next" means "least recently used"
		in autobuffer mode.  In noautobuffer mode, "next" means
		next in numeric sequence.  (The ":n file ..." version of
		the command is not supported.)

	:rename-buffer   Rename the current buffer.  Prompts for a new name.
		Does not affect the filename associated with the buffer.
		Use ":f" to do that.  This command is useful for renaming
		the "[Output]" buffer, if you wish to preserve its
		contents, but run a new command.

	:rewind	Go to the first buffer.  This is used only in 'noautobuffer'
		(vi-style buffering) mode.  It does nothing in "autobuffer"
		mode.  Remember that "autobuffer" mode is the default.

	:b	Edit a buffer.  Recalls the named buffer.  Does not look for
		a file of that name.  Will find "invisible" buffers.

	:ki	Kill a buffer.  Remove the buffer and its contents from the
		editor.  Will ask if changes to the buffer should be
		discarded.

	^X-e	Edit the file whose pathname appears under the cursor.  For
		example, if you are editing a makefile, you could edit one
		of the source files by placing the cursor at the start of
		its name and using this command.  Note that this does not
		know about some characters that your shell might usually
		translate for you, like the '$' in '$HOME'.

	^X-k	Kill the buffer whose name or filename appears under the
		cursor.

	*	Display a list of all buffers, or make that display go away
		if it's already present.  Leave your finger on the key, and
		it's easy to create and destroy the list.  The buffers are
		numbered; the numbers correspond to the history numbers
		shown and used by the '_' command, described above.  (If
		the buffer number is greater than 9, then the "nn_" form of
		the '_' command must be used, since '_' will only accept a
		single following digit.)  The order of the list is either
		most-recently-used, or fixed, depending on the setting
		of "autobuffer" mode (see below).  vile attempts to keep
		the contents of the buffer list window up to date if it
		is left up on the screen while other buffer manipulation
		commands are given.

	^A-*	Always display a list of all buffers.  Useful for updating the
		list if it's already on the screen but may be out of date.
		Any argument will cause the list to include _all_ buffers,
		even those normally considered "invisible".  (For example,
		macros are stored in "invisible" buffers.)  [This command
		isn't as necessary now that the buffer list is maintained
		dynamically...]

Window manipulation commands:
-----------------------------

	^X-2	Make Two windows.  Splits the current window in half. This
		is the usual way to create a new window.
	^K or ^X-0	Get rid of (Kill) this window.
	^O or ^X-1	Make this the Only window on the screen.

	^X-o	Move to the next window.
	^X-O	Move to the previous window.

	v	Make the current window smaller.
	V	Make the current window larger.

	^A-^D	Scroll the next window down half a screen.
	^A-^U	Scroll the next window up half a screen.
	^A-^E	Scroll the next window up one line.
	^A-^Y	Scroll the next window down one line.
	(The previous four commands are useful when comparing two buffers.
	 Mnemonic -- think of them as affecting the "A"lternate window.)

	zH zM zL  These are synonyms for vi's 'z+', 'z.', and 'z-', which
		position the line holding the cursor at the top, middle, or
		bottom of the screen, respectively.

	^X-^R	Scroll the window right or left by 1/3 of a screen, or by the
	^X-^L	number of columns specified.  Changes the "sideways" value.
		Neither of these commands will actually move the cursor
		in the buffer -- they only reframe your view into the buffer.
		If the cursor would be forced to move off-screen (which is
		of course impossible and undesirable) as a result of the
		requested sideways scroll, then nothing at all will happen.
		The commands are arguably crippled as is.

	If for some reason you can't get your screen set right via a
	TERM variable, try the ":screen-rows" or ":screen-columns"
	commands (which take their args (number of rows or columns
	respectively) before you type the ":").

	[ Personally, I put the following bindings in my .vilerc:
	    bind-key split-current-window ^T	; split into 'T'wo windows
	    bind-key next-window ^N		; 'N'ext window
	    bind-key previous-window ^P		; 'P'revious window
	Since ^K already 'K'ills a window, and ^O makes it the 'O'nly window,
	these give more mnemonic, and faster, access to multiple windows.
	(These would be the default, but ^N, ^P, and ^T have other meanings
	in real vi (all of which have alternate bindings in vile.) ]

File manipulation commands:
---------------------------

	The usual ":e", ":r", ":f", ":w" commands are available, though
	only ":e!" and ":w!" are available of the "!" options.  The ":r"
	command reads the named file in after the current line.  To read a
	file before the first line, use ":0r".  File completion works like
	command completion: using the TAB and '?' keys you can complete or
	see next character choices.  The ":w!" and ":x!" are present, and
	are synonymous with ":w" and ":x" since there is no "readonly" mode
	to override.  (Actually, ":w!" is not quite synonymous -- it can be
	used to force a write when an attempt to create a backup file has
	failed.  See the "backup-style" mode, below.)

	The commands ":ww" and ":wwq" correspond roughly to ":w" and ":wq",
	but they each write all modified buffers, rather than just the
	current one.  Giving any numeric argument to ":ww" (i.e.  "1:ww")
	will suppress the per-file and "Press return to continue" message.
	This may be useful when using the command from within a macro.

	As in vi, ranges of lines specified by line numbers (including '.',
	'$', and '%' shorthands) or marks may precede these commands.
	Unlike vi, search patterns cannot be used as line specifiers.

	In addition, two non-"colon" commands have been added:

	^R	Prompts for a filename, and then reads it in _above_ the
		current line.  If a register is specified (e.g. "a^R ),
		the file is read into that named register, but not inserted
		into the current buffer.

	^W	is a writing operator, which prompts for a filename, and
		writes the specified region to that file.  Like all operators,
		if the command is repeated, as in ^W^W, then lines are
		affected.  Use 10^W^W to write 10 lines.

		If a register is specified (e.g. "a^W ) then the command
		is _not_ an operator, but writes the specified register to
		the named file.

Shell Access
------------

	Anywhere a filename is valid, a command name is also
	valid, entered in the form "!shell-command".  The whole line is
	handed to the shell, and the read or write operation is done on
	the commands standard input or output, as appropriate.  Thus
	you can type ":e !date" to edit a copy of today's date.

	The ": !cmd" shell escape works pretty much as it does in vi.
	The command ":!!" will rerun the previous such shell command.

	The '!' operator works as a filter, as expected.

	In addition, the ^X-! command runs a shell command and captures
	its output in a specific buffer, called "[Output]".  This is
	almost identical to ":e !cmd", except that in that case the buffer
	is named according to the command name.

	These "output capture" commands are most useful in conjunction with
	the "error finder", '^X-^X', described below.

	On systems supporting job control, ^Z (or ":stop") will suspend vile.

	The :cd and :pwd commands are of course supported.  Unlike vi,
	filenames will track their directory of origin, so you can't simply
	edit a file in one directory, cd to another, and write it.  You
	must explicitly write to ./filename in the new directory to
	accomplish this.  ":cd -" will return to the previous directory, as
	it does in some shells.

	Giving an argument to the ": !" (also called "shell-command" when
	writing macros) will suppress the "Press return to continue" message
	after the command runs.

Text manipulation command:
--------------------------

	Remember, these are only the new or different commands.  The
	standard vi set should still work.

	The vi "global" (":g") command is present.  So is the "substitute"
	(":s") command.  These both look pretty different while they're
	being used than they do in vi, due to the interactive nature of
	the prompting.  And, since the searching is done right after the
	pattern is entered, there may be a slight delay while you're trying
	to finish typing your complete command.  (If the pattern does not
	exist, you may not get to finish typing your command at all.)  You
	can use the commands just as you would have in vi, i.e.
	":g/oldpat/s//newstring/" will work.  But you won't see any of the
	'/' characters.  Try it-- you'll get the idea.  Line ranges are not
	possible on ":g", but they are on ":s".

	The ":g" command can be followed by any of l (list), p (print),
	< (left shift), > (right shift), r (read file), d (delete),
	L (lower case), U (upper case), ~ (flip case), put (append
	yanked text), Put (prepend yanked text), s (substitute),
	trim (trim trailing whitespace).  For example, ":g/pattern/Put"
	will insert the contents of the default yank register just
	above every line containing "pattern".   The ":g" command can
	only be used over the entire file -- smaller regions are not
	permitted.

	The ":v" counterpart to ":g" is also implemented -- it performs the
	given command on all lines that don't match the given pattern.

	The substitute command can be followed by any of 'g', a digit, or
	'p', to do the substitution for all occurrences, the n'th
	occurrence, or to print the resulting line respectively.  You can
	also add a 'c', and you will be asked to confirm each replacement
	before it occurs.  The text being replaced will be highlighted,
	and you can answer with 'y', 'n', 'q', or 'a'.  'a' will suppress
	further prompting, and will do the rest of the replacements.

	The ":&" and '&' commands work much as they do in vi, and repeat
	the last substitution.  The '^A-&' command is a new operator (see
	below), so it can work on regions: for example use '^A-&}' to
	"repeat the previous substitution over the rest of this paragraph".

	Infinite Undo
	--------------
	The regular undo ('u') and line-undo ('U') are available for all
	commands.  They are a little more predictable than their vi
	counterparts, since they do not share the default yank register for
	their operation.  Also, line-undo ('U') is available until the next
	change anywhere in the file, rather than until you leave the line.

	vile also lets you undo all changes made to a buffer since it was
	first edited (so-called "infinite undo").  The '^X-u' command will
	undo changes, one by one (or given a count, several at a time).
	The '^X-r' command will walk forward, redoing the previously undone
	changes one by one.  A fresh change to the buffer will cause
	previously undone changes to no longer be redoable.  Remember that
	with key rebinding, you can change your 'u' or 'U' command to be an
	infinite undo, making it easier to type.

	In addition, the '.' command, which normally re-executes the last
	buffer-modifying command, has special behavior with respect to
	undo.  If the '.' command immediately follows one of the undo
	commands ('u', '^X-u', or '^X-r'), then it will perform another
	undo or redo, as appropriate.  If there are any intervening commands,
	then '.' will re-execute the last command prior to the undo.  [ This
	modification to the behavior of "u." does not conflict (much) with
	traditional use of '.', since by definition, the sequence "u." is
	always identical to "uu", and the latter is more easily typed.
	(Credit goes to the designers of "nvi" for this trick. ]

	The number of changes stored in the undo "history" is controlled by
	the numeric mode "undolimit".  The default history length is 10 --
	that is, only 10 changes may be undone.  Set the undolimit to 0 for
	truly infinite undo.  This can consume a lot of memory.

	The cursor position after an undo may not always be the same as it
	would be in vi.

	Operators
	---------
	vi has a class of commands known as "operators".  Operator commands
	are always immediately followed by a motion command.  The region of
	text affected by an operator is bounded on one end by the initial
	position of the cursor, and on the other by the cursor position
	after the motion is completed.  Thus the delete operator ('d') can
	be followed by the word motion command ('w'), causing the next word
	to be deleted.  The sequence "dG" will delete from the cursor
	through the end of the file, and "d/junk" will delete to the next
	occurrence of the string "junk".  As a special "honorary" type of
	motion, operators can all be "stuttered" to affect lines.  Thus
	"dd" deletes one line, "4dd" affects 4 lines, etc.

	Most operators affect the region exactly, but some cause only whole
	lines to be affected.  This is usually a function of what sort of
	motion follows the operator, but can sometimes be affected by the
	operator itself.  The best example of motions having different
	effects is the 'goto-mark' motions, the ''' and '`' commands.  If a
	mark is set, say mark 'a', with the 'ma' command, then if the
	command d`a is executed, the exact text between the cursor and the
	mark will be deleted.  If, on the other hand, the d'a command is
	used, the deleted region will include the lines containing the
	cursor and the mark in their entirety.

	Some operators in vile can be "forced" to affect regions of whole
	lines, though the motion wouldn't normally imply it, by using the
	'^X' form of the command.  (It's not really forced -- it's really
	a separate operator.)  For example, "d%" (assuming you are on a
	curly brace) will delete a C-style block of code.  "^X-d%" will
	delete that same area, plus anything else on the lines containing
	the curly-brace endpoints.

	Note that some operators always affect whole lines, no matter
	how the motion is specified.  The '!' operator is an example:
	"!w" will always filter an entire line, and not just a single word.

	vile extends this notion of the "shape" of a region by adding
	the concept of rectangular regions, whose boundaries are
	delimited by the rectangle whose opposite corners are at the
	cursor and at the other end of the motion, respectively.  See
	the section "Rectangular regions" below.

	The "list-operators" command will show all available operators.
	The "list-motions" command will show all available motions.
	Any operator may be followed by any motion.

	There are several new operator commands in vile:

	^A-~	Is the operator form of the '~' command, so "^A-~~"
		changes the case of all characters on the current
		line, "^A-~w" does it to a word, "3^A-~}" does it for
		3 paragraphs, etc.  (In vile, the simple '~' command
		will take a repeat count, unlike some versions of vi.
		If you wish it to be an operator, rebind '~' to the
		"flip-til" command.)
	^A-u	Like ^A-~, but converts the region to upper case.
	^A-l	Like ^A-~, but converts the region to lower case.

	^A-f	Format the region based on the current fill column.  The
		initial indentation of both the first and second lines of
		each "paragraph" in the region are preserved, and all
		subsequent lines get the second line's indentation.  This
		makes indented/outdented paragraphs (like this one) work
		correctly.  (This is intentionally _not_ the same behavior
		obtained by using "!fmt", since that behavior is obviously
		available elsewhere.)  The usual usage of this command is
		"^A-f}", which reformats the current paragraph.  The
		re-formatting begins again with each new paragraph, where a
		paragraph has the same boundaries used by the '{' and '}'
		commands -- i.e. blank lines, or lines beginning in .I .L
		.P .Q or .b.  This makes it possible to use "3^A-f}" or
		"^A-fG" to reformat multiple paragraphs.  The reformatting
		operation knows a little about both C and shell comments,
		and will attempt to do the "right" thing with lines that
		start with '#' or '*' characters.  (It also knows about the
		'>' character, making it fairly easy to reformat mail and
		news inclusions...  but is it ethical?  :-)

	^X-s	For every occurrence of a search string, put in a replace-
		ment string.  This is similar to "s/pattern/replacement/g"
		over the region.

	^A-&	Is an operator in vile, similar to the traditional & command.
		It repeats the last substitution over the specified region.
		(Unlike the '&' command, this one will remember trailing
		g, p, l, or numeric options.)

	^X-d	Delete the region, including the lines it starts and ends on.
	^X-c	Change the region, including the lines it starts and ends on.
	^X-y	Yank the region, including the lines it starts and ends on.

	^A-t	Trim trailing whitespace from all lines in the region.

	^A-<SPACE> Convert tabs to spaces, using the current tabstop value.
	^A-<TAB>   Convert as many spaces to tabs as appropriate.

	^A-b	Blank out a region.  Turns the region to whitespace.  Useful
		with rectangular regions.
	^A-r	Open up a rectangle.  Text to the right of the left edge
		of the rectangular region will shift to the right by the
		width of the rectangle, leaving a whitespace "hole".
	^A-q	Sweep out a rectangle with multiple motion commands.  See
		description of 'q', below.

	^A-s	Select and yank a region.  The region will be highlighted
		on the screen, as if it had been swept by a mouse.  It
		is also yanked, as with the 'y' operator.  This operator
		is useful in combination with the ^S motion command, which
		lets one reference the selected region with other operators.
		(If you use this command much, it is recommended that you
		bind it to and easier to type sequence, such as 'S'.)

	Text insertion
	--------------
	^X-p	Causes the previously yanked or deleted text, no matter
		how it was obtained, to be inserted after the current line.
		Usually text that did not consist of whole lines where it
		came from is inserted immediately following the cursor.
	^X-P	As above, but the text is put before the current line.
		Thus "dw" followed by a "p" command does a normal insertion
		of the deleted word, whereas "^X-p" results in the word
		being inserted on a line by itself.

	R	vi's overwrite mode is supported.  Note that the combination
		of overwrite mode and the (ANSI) arrow keys can be used to
		give a "picture drawing" mode of operation: anything you
		type goes into the buffer without moving adjacent text, and
		you can move around using the arrow keys without leaving
		overwrite mode.  Hint: start with a buffer full of lines
		that consist entirely of blanks (as opposed to blank
		lines).

	^A-i	Like their 'i', 'o', and 'O' counterparts, but any autoindent
	^A-o    or cmode setting is ignored for the duration of this insert.
	^A-O	These are most useful when pre-formatted text is being
		pasted, as when using a mouse.

	Searching
	---------
	^X-/	Does a forward search for the "word" located under the
		cursor.
	^X-?	Does a reverse search for the "word" located under the
		cursor.
	^A-/	Does not do a search, but sets the search pattern to the
		"word" under the cursor.  Useful for "picking up" a word
		from one buffer, and searching for it in another.

	The following two commands may not always be present in vile,
		depending on how it was built:
	^X-S	Incremental forward searching.  As you enter the search
		string, the cursor is advanced to the next match with
		what you've typed so far.  Use ^F and ^R to continue the
		search forward or in reverse, using the current pattern.
	^X-R	As above, but in reverse.

	Tags
	----
	vile supports vi-style "tags" files.

	":ta" or ":tag" allows you to enter a tagname to locate.  Changes
		to that file and location.
	^]	Uses the identifier currently under the cursor as the
		tagname.
	^T or ^X-^] or ":pop" - pops to the file and location just previous
		to the last tag command.

	When one of these commands is used, vile will (by default) look for
	a file named "tags" in the current directory, and load it into a
	hidden buffer for use during tag searches.  This buffer is editable
	if you wish (":e tags"), but will not appear in the buffer lists.
	If a buffer named "[Tags 1]" is already available when a tag is
	first requested, it will be used instead of a file found by
	searching the tags setting, and of course will remain visible.

	The name of the default tags file may be changed with "set tags"
	(see "tags" under "Editor modes", below).  If multiple filenames
	are given in the "tags" setting (separated by whitespace), they are
	searched in order, and placed in buffers named "[Tags 1]", "[Tags 2]",
	"[Tags 3]", etc.

	Tags searched for using '^]' will always be matched exactly.
	If the ":ta" form of the command is used, tag matches will be
	exact unless the mode "taglength" is set non-zero, in which case
	the first tag matching that many characters will be used.

	Filenames referred to in tags files are expanded, so environment
	variables and shell special characters like ~ may be used.

	The stack of buffer locations waiting to be "popped" to with the
	'^T' (or '^X-^]' or ":pop") command may be viewed with the
	"show-tagstack" command.  The "[Tag Stack]" buffer is animated --
	it will dynamically keep track of current tag references.

	Limitations:  In a real vi-style tags file, there are three tab
	    separated fields.  The first contains the tagname.  The second
	    contains the (relative or absolute) filename.  Everything after
	    the second tab is an arbitrary ex-mode command.  vile is not
	    quite so flexible as regular vi, and only supports a couple of
	    commands in that last "field".  It can be a line number, in
	    which case the tag is an absolute index into the file.  Or, it
	    can be a search command.  If it begins with a '/', the search
	    goes forward.  If it begins with a '?', the search goes
	    backward.  In either case, the matching delimiter _must_ be the
	    last character on the line in the tags file.  And, in either
	    case, the second character of the command _must_ be a '^',
	    signifying an anchored match of the search string.  If a '$' is
	    found just before the trailing delimiter, then the pattern must
	    match the whole line, otherwise it can be just a leading
	    substring match.  Also, the tag pattern is _not_ a regular
	    expression, but a simple case-sensitive string match.

	    All of this isn't as bad as it sounds, since ctags, the program
	    most people use to generate tags files, does generate exactly
	    this format.  (Surprise, surprise.)  However, if you attempt
	    to create your own tags files, or have other tools that do so,
	    you should be aware of these limitations.

Miscellaneous commands
----------------------

	^A-d	Remove all blank lines ("deblank") containing or immediately
		following the current line.  With an argument, will force
		that many blank lines at that point, regardless of how
		many were there before.  Moves current location forward,
		to allow repeated use.

	^X-^X	The "error finder".  Goes to the next file/line error pair
		specified in the last buffer captured from a command's
		output.  This buffer is usually created with the ^X-!
		command.  For example, "^X-!cc -c junk.c" puts all of the
		compiler output into the buffer named "[Output]".
		Repeatedly hitting ^X-^X will position the editor at each
		error in turn, and will eventually start over again at the
		top.  The buffer searched for "errors" will be the last
		shell command run, or the buffer named with the "error-
		buffer" command.  The "Entering directory XXX" and "Leaving
		directory XXX" messages that GNU make puts out with the -w
		switch are honored, so that files are found with the
		correct path.  (Tip: I use the following macro to quickly
		grep a source directory for the string under the cursor:
		    use-register g load-register "^X!egrep -n : *.[chs]^M"
		where the ^X and ^M are each single control characters,
		entered using ^V to escape them.  Then I invoke with @g to
		execute. [NB: this macro won't work with DOS versions of
		vile, since ':' doesn't expand to the word under the cursor
		in those versions, since it conflicts with the driver letter
		separator.)

		Unfortunately, the parsing of the command output that vile
		does to get the file and line numbers is currently
		hard-coded.

	^X-t Set or report on the tab-stop width.  To set, the spacing must
		precede the command, as in "4^X-t".  The "set tabstop"
		command described below does the same thing.  The status
		output indicates whether the buffer is currently using the
		local or global copy of the tabstop value.

	^X-f Set the local fill-column to be used with ^A-f and auto-wrap
		mode on insert.  The default value is 7/8's of the screen
		size, with a maximum of 70.  Since arguments come before
		commands, you type: 65^X-f.  The "set fillcol" command does
		the same thing.  The status output indicates whether the
		buffer is currently using the local or global copy of the
		tabstop value.

	^X-X	Set encryption key.  (not well tested, but hopefully not
		broken)  OPT_ENCRYPT must have been on when vile was built
		for this to do anything.

	K	Count prefix.  The first time you type it, it is equivalent
		to an argument of 4 to the following command.  If you repeat
		it, it becomes worth 16, the next time 64, etc...

	%	In addition to finding matching braces, brackets, and
		parentheses, the '%' command will find matching #if's,
		#ifdef's and C-style comments.  If the cursor is on the #
		of "#ifdef"/"#if", the '%' command will find the matching
		"#endif" or "#else".  On an "#else" it will find "#endif",
		and on "#endif" it will go back up to the "#ifdef"/"#if".
		If the cursor is on any part of a "/*" or "*/" sequence, it
		will find the appropriate corresponding C comment endpoint.

	\	Identical to the ` motion, in that the cursor moves to
		the specified mark (i.e. \a moves to mark 'a').  When
		used with an operator command, the resulting region is
		rectangular instead of "exact".  This is similar to
		the ' motion, which also goes to [the line holding] the
		mark, and causes regions to become "full line" regions.

	q	A "quoted motion" command.  After entering 'q', more motion
		commands are accepted until another 'q' is entered.  The
		result of the motion is the cumulative effect of all the
		entered motions.  Thus, one might type:
			dq<arrow><arrow><arrow>...<arrow>q
		to delete all of the text between the starting point
		and the final cursor position.

		Any motion command can appear in between the two 'q'
		commands.  If used alone, i.e. not in an operator
		context, then the spanned text is selected, highlighted,
		and yanked as a side effect.  The resulting selection can
		then be manipulated with the ^S pseudo-motion, below.

		Most motions will select up to but not including their
		endpoint.  The 'e', 'E', 'f', 't', and '%' commands are
		exceptions to this.  If used in an operator context the
		cursor position may sometimes appear incorrect.  This
		is because operators sometimes change the cursor location
		internally to force the motion to do the "right" thing,
		and the 'q' command makes these internal "fudge factors"
		visible.  An example of this is "dq%q" which does the
		right thing (assuming the cursor is on a '(' to start)
		but which looks wrong, since the cursor will overshoot
		the ')' before the second 'q' is typed.

		If a mouse is available, whether in an xterm via the
		"xterm-mouse" setting, or in xvile, then button 1 can be
		clicked to do the extensions, since it, too, is a motion
		command.  (Of course in xvile, it is easier to simply
		"click and drag" -- the 'q' command isn't really necessary
		at all.

		Use the repeat-count to specify types of selection: exact=1
		(default), full-line=2, rectangle=3.

	^A-q	As above, but the motions will sweep out rectangular regions.

	^S	A motion, or "pseudo-motion" command.  If a region of
		text has been previously selected, either with the mouse
		(if available) or with the keyboard selection operator
		(^A-s) it can be referenced by any other operator by
		applying that operator to the ^S motion.  As an example,
		suppose a word is selected with the mouse, or with ^A-sw.
		Then, from anywhere in that buffer, one can use d^S to
		delete that word.  ^S used by itself will move the cursor
		to the start of the selected region.  ^S applied to
		the selection operator (^A-s) will extend the current
		selection to include the current location of the cursor.

		^S makes it possible to select any region (including
		rectangular regions) of text with a mouse, and then apply
		any vi operator to that region.

	=	If "visual-matches" is set, then vile will highlight all
		occurrences of a pattern that is searched for with one of
		the usual searching commands.  The '=' command will clear
		this highlighting, until the next search for a different
		pattern.


	Vile can display more of its internal "state" than traditional vi.
	Portions of the internal "state" may be viewed using various
	"show-xxx" commands:

	show-abbreviations -- displays list of shortcuts defined with the
		":abbr" command.  (synonymous with ":abbr<CR>")

	show-buffers -- displays the current list of available buffers.  Given
		any numeric argument, will list _all_ buffers, even those
		normally invisible or considered temporary.

	show-commands or show-bindings -- displays the list of commands
		and the keys bound to them.

	show-global-modes, show-modes -- both synonymous with ":set<CR>"

	show-help -- synonymous with ":help", '^A-h', etc.

	show-history -- displays the user's command line history.

	show-mapped-chars -- displays the strings mapped for command mode
		with ":map".  (synonymous with ":map<CR>")

	show-mapped!-chars -- displays the strings mapped for insert mode
		with ":map!".  (synonymous with ":map!<CR>")

	show-system-mapped-chars -- displays the strings mapped to
		represent the terminal's function keys.

	show-registers -- displays the current contents of the named and
		numbered registers.

	show-tagstack -- displays the contents of the "tags stack", the
		list of locations from which the ":ta" or '^]' commands have
		been used, and to which the ":pop" and '^T' (or '^X-^]')
		commands will return.

	show-terminal-chars -- displays the list of special chars normally
		associated with the TTY driver, i.e. backspace, interrupt,
		suspend, etc.

	show-variables -- displays the list of vile $variables and user
		%variables, and their values.

New Registers
-------------
	In addition to the usual "a through "z, and "1 through "9, vile
	has additional registers.

	The register named '<' contains the last few hundred keystrokes
	that have been typed by the user.  The principle use for this
	is to make it easier to create :map commands based on commands
	you've already given.  [It's also useful sometimes when debugging
	to be able to see what key sequence led to a problem...]

	The register name '.' contains the current selected text in xvile.

	The register name '"' is a synonym for the default unnamed register,
	which is also sometimes referred to as register 0.

Completion
----------
	Many responses to vile prompts need not be typed in their entirety.
	vile can complete the response for you.  This applies to command
	names, file names, vile modes, vile variables, and the "terminal
	characters".

	To invoke vile completion, type a few characters and hit TAB (or
	your current "name-complete" terminal character).  Hitting it a
	second time will pop up a window containing the list of possible
	completions.  The window will go away when the current command
	is finished.

	You can also type a question mark (or the current "test-completions"
	terminal character) to display a list of the characters that you
	would have to type to complete the command.  For example, to
	complete
		:unm?			-- you type
		:unm{a}[pr]		-- you see

	This style of completion-display shows curly braces around the
	string that will be supplied by pressing TAB, and square brackets
	around characters that you must type to make the command unique.

Arrow keys
----------

	vile will understand your terminal's arrow keys, as long as they
	are described correctly in the termcap/terminfo database.
	The keys are interpreted as function keys, and are by default bound
	to the up, down, left, and right screen motions.  These bindings
	are honored in insert mode as well as command mode.

Rectangular regions
-------------------

	Just as the regions defined by vi's commands and motions can either
	be "exact", or encompass "full lines", regions in vile can in
	addition be "rectangular".  The easiest way to use a rectangular
	region is with the '\' motion, which, like '`' and ''', goes to a
	named mark.  The region it describes, however, is "rectangular"
	(instead of "exact" or "full line").  The following operators know
	how to correctly act on rectangular regions:

	^A-r	Opens up a rectangle.  Text to the right of the left
		edge of the rectangle is shifted right by the width of
		the rectangle.
	>	Shift right.  Identical to '^A-r' when region is rectangular.
	d	Deletes the (rectangular) region.  Text to the right moves
		left to fill the rectangle.
	<	Shift left.  Identical to 'd' when region is rectangular.
	y	Yanks the (rectangular) region.  (vile remembers that the
		yanked text is rectangular in shape.
	c	Change the region.  If the region is _not_ rectangular,
		insert mode is entered after the region is deleted.  If
		the region _is_ rectangular, the user is prompted for
		text with which the lines of the rectangle will be filled.
	^A-u ^A-l ^A-~ ^A-b	These four operators perform their character
		transformations on rectangular regions, as well as exact or
		full-line regions. (uppercase, lowercase, flip-case, and
		blank, respectively)

	p P 	The 'put'ting commands know whether the text being 'put' was
		originally rectangular, and will do a rectangular insert
		of the text, in front of or behind the cursor.  The
		cursor position defines the upper left corner of the
		insertion.
	^A-p	These two forms of the put command force the text being
	^A-P	'put' to be inserted as if it had been rectangular when
		originally yanked or deleted.  The width of the rectangle
		is the length of the longest line in register being 'put'.

	Note that because it is sometimes hard to manipulate rectangles
	containing or bordering on tab characters, currently (for some
	operations) vile "detabs" the region being operated on before
	commencing, and re-entabs the lines again after the operation.  The
	re-entabing is limited to leading whitespace, and of course is
	suppressed if "notabinsert" mode is set.  [ This misfeature is
	arguably a bug, and may be fixed.  In the meantime, you've been
	warned. ]

Editor modes
------------

	Modes come in three "flavors".  They are universal, and affect the
	editor generally, or are associated with either buffers or with
	windows, and are usually inherited from a set of "global" buffer
	and window modes.  The value of a buffer or window mode will track
	changes to the respective global mode, until the "local" value is
	set independently of the global one.

	To set or change a global mode, use ":set".  To remove the mode,
	use ":unset", ":setno", or ":set" with the modename prefixed with
	"no".

	To set and reset local modes, use ":setl", ":unsetl", ":setlno".

	To display modes, use ":setall", ":modes", or ":set all".  Local
	mode values are only shown if they differ from the global values,
	whether they have been independently set or not.  The "local"
	version of the set/unset commands ("setl"/"unsetl") do not make
	sense when used with universal modes, since there is only one
	copy of these.

	The possible modes, with synonyms in parentheses, and a trailing U,
	B or W indicating whether the mode is universal, or belongs to
	buffers or windows, are:

	alt-tabpos (atp) If set, vile will position the cursor over tab and
		control characters the way emacs would, that is, at the
		start of a tab or control character display sequence.  If
		turned off (the default), the cursor is positioned over
		tabs and control characters the way it would be in vi, i.e.
		at the end of the tab or control character display
		sequence.  (To match the behavior of earlier versions of
		vile, should be set.) (U)

	animated Controls whether vile automatically updates the contents of
		scratch buffers when their contents would change.  The animated
		buffers include:
			[Binding List]
			[Buffer List]
			[Map Sequences]
			[Map! Sequences]
			[Registers]
			[Settings]
			[Terminal Characters]
			[Tag Stack]
		Turning off "animated" is rarely necessary: the capability
		is present mostly as a debugging aid.  (B)

	autobuffer (ab) Controls whether vile uses "most-recently-used"
		style buffering, or vi-style (command-line order) buffers.
		That is, if autobuffer is on, then buffers are sorted in
		order of use, in that buffers not frequently used will
		drift to the end of the list.  If this mode is not on, then
		vile will behave more like vi, in that buffers remain in a
		fixed order, that in which they were edited. (U)

	autowrite (aw)  vile will write out any changed buffers for which
		this mode is set before performing a ^Z, "stop", "suspend",
		":!<cmd>", or '^X-!<cmd>'.  The ":sh" command is not
		affected, nor is ":stop!" or ":suspend!".  Since buffers
		inherit the global value of a mode, simply setting the
		global autowrite value will cause all buffers to be
		auto-written.  Individual buffers can be forced or
		prevented from autowriting by setting the local value of
		the mode for those buffers appropriately.  [In real vi,
		autowrite mode will also force buffers to be written when
		switching between files.  This is unnecessary in vile.] (B)

	autoindent (ai) During insert, newly created lines inherit their
		leading indent from the previous line in the buffer. (B)

	autosave (as) Automatic file saving.  Writes the file after every
		'autosavecnt' characters of inserted text.  Other file
		changes are not counted.  (B)

	autosavecnt (ascnt) How often (after how many inserted characters)
		will automatic saves take place.  256 by default. (B)

	backspacelimit (bl)  When in insert mode, this controls whether
		one can backspace past the point at which the insert began. (B)

	backup-style  Specifies the style used for creating file backups
		when a file is written.  Can have values of "off", ".bak",
		and (under UNIX) "tilde", for no backups, DOS-style .BAK
		files, and file.c~ style backups, respectively.  Files
		are copied before being written, to protect links to
		the original file.  Permissions, modification and access
		times are all preserved.  If creation of the backup fails,
		the write of the file will fail, unless it is forced
		using the ":w!" form of the write command.  (U)

	bcolor	On systems supporting this, will set the background color.
		Currently only DOS can do color, although the X11 version
		(xvile) can be given colors at startup or via .Xdefaults.
		See notes about the color palette down below, under DOS
		specifics.

	check-modtime  Check modification-time.  If a file has changed since
		it was last read or written, vile will issue a "file newer
		than buffer" warning and prompt appropriately for
		confirmation when 1) popping up a window on an existing
		buffer, 2) reading or writing the buffer, or 3) after
		performing some shell command.  The prompt will occur only
		once, unless the modification time of the file changes
		again, in which case the warning will be repeated.  The
		warning will be repeated in any case if the file is being
		written.  Invoking a shell, or suspending/restarting vile,
		will cause all visible buffers (those currently in windows)
		to have their times checked immediately.

	cmode   C-code mode.  Also useful for other languages.  Maintains
		current indentation level automatically during insert, like
		autoindent, above.  If a line ends with a '{', '(', or ':',
		then the next line indents further.  If a line begins with
		a '}' or ')', it is lined up with the line containing the
		matching '{' or '('.  If a line starting with '#' is
		inserted it is moved to column 1.  Additionally, if a line
		begins with a '#' character, it will not shift right with
		the '>>' command.  If the global cmode is set, then the
		buffer's C mode is turned on automatically only for files
		whose names are matched by the c-suffixes regular
		expression (see below).  (B)

	crypt	Causes files to be encrypted.  This is NOT compatible
		with the UNIX crypt(1) routines, and may not be built
		into your version of vile by default. (B)

	c-shiftwidth (csw) Sets the value for the shiftwidth (see below)
		which will be used if a file is in cmode.  (B)

	c-tabstop (cts) Sets the value for spacing of tabstops which will
		be used if a file is in cmode.  (B)

	c-suffixes (csuf) A regular expression describing filenames for
		which cmode will be set.  This is arguably misnamed, since
		the regular expression need not describe only suffixes. (U)

	comments A regular expression defining commented paragraph
		delimiters.  This is used in addition to the "paragraphs"
		expression (see below) when reformatting a region.  The net
		effect is that paragraphs inside of these comments are
		preserved when doing text reformatting, but are not
		reachable with the '}' and '{' motions.  (B)

	dirc	Causes vile to check each name when scanning directories for
		filename completion.  This is slower, but provides additional
		information allowing you to distinguish between directory and
		file names in the prompt.  (U)

	dos	On input, if the global copy of this mode is set, then
		incoming CR/LF pairs are taken as line terminators, the CR
		characters are stripped out, and the local dos mode is set
		for the buffer.  (Actually, the local dos mode is only set
		if the _majority_ of lines had CR characters at the end.)
		If global dos mode is _not_ set, then incoming CR
		characters will be left visible on the screen (as '^M'),
		and the local mode will not be set.

		On output, when writing a buffer with local dos mode set,
		all lines will be terminated with CR/LF pairs, rather than
		the usual single LF.

		When buffers representing non-existent files are created
		they will inherit the line-style of the operating system
		(LF-only on UNIX and VMS, CRLF-style on DOS derivatives)
		regardless of the global setting of dos mode.

		Setting dos mode makes editing binary files unreliable.
		The global value for this mode is set on by default in DOS
		versions of vile, and should therefore be turned off if
		doing binary editing.  (B)

	errorbells (eb) Controls whether a bell sounds (or whether the
		screen flashes, if "flash" mode is on") when an error
		occurs. (U)

	expand-chars Controls the set of characters that are expanded in
		command lines.  These include
			'%' (the current buffer),
			'#' (the alternate buffer) and
			':' (the token at the cursor position).
		(U)

	expand-path Controls whether %/# are expanded to the full pathname
		of a buffer, or just to its basename (i.e. the name with
		the path stripped off).  (U)

	fcolor	On systems supporting this, will set the foreground color.
		Currently only DOS can do color, although the X11 version
		(xvile) can be given colors at startup or via .Xdefaults.
		See notes about the color palette down below, under DOS
		specifics.

	fence-pairs  Each pair of characters in this string is taken to be
		a set of "fences", which should be matched with the '%'
		command.  The default value is "{}()[]", which produces
		normal vi behavior.  This can, for instance, be augmented
		with the '<' and '>' characters ("{}()[]<>") to cause angle
		brackets to be matched as well.  See "showmatch" mode for
		another use of the "fence-pairs" mode.  (B)

	fillcol (fc)  Sets the value for the fill column, which is the
		column at which autowrapping and region formatting will
		break lines.  (B)

	flash   If your terminal can, will flash the screen rather than
		beeping on errors.  No audible or visible indication will
		occur at all if "errorbells" mode is not set on.  (U)

	glob	Controls how wildcard characters (e.g., '*' and '?') are
		treated in prompts for filenames.  Set glob to 'off' to
		disable expansion, or to 'on' to use the internal globber.
		The internal globber will handle *, ?, [a-z] style ranges,
		environment variables, and the ~user notation for finding
		home directories.

		On UNIX, glob can be set to be a pipe command that
		will expand more wildcards.  The default value of
		glob on UNIX is "!echo %s", which should provide globbing
		that matches that of your shell.  If set to a command that
		will separate filenames with newlines or nulls rather than
		spaces, then filenames containing spaces may be more easily
		edited.  ("!/bin/ls -d %s" is one possibility, "!glob %s"
		is another if you use csh.) (U).

	history (hi) When true (the default), commands from the :-line are
		logged in a buffer [History].  Turning this off causes the
		buffer to be removed.  (U)

	horizscroll (hs) If the cursor is moved "off-screen", this mode
		controls what happens.  If set (as it is by default), the
		whole screen will shift sideways to make the cursor position
		visible.  If not set, then only the current line will shift,
		which may be desirable on slower displays. (W)

	ignorecase (ic) Text searches normally match the pattern exactly.
		With this set, searches are case-insensitive. (B)

	implybuffer (ib) Causes vile to create a buffer when you write to a new
		file, or read from one (e.g., with ":r").  (U)

	linewrap (lw) Displays lines that are too long to fit on one line as a
		series of "wrapped" lines.  Overrides left/right scrolling
		controlled by "sideways" and "horizscroll" modes.  (W)

	list	(li) The buffer will be displayed with tabs and newlines made
		visible, instead of as whitespace. (W)

	magic   Honor unescaped meta-characters in search strings.  See the
		section "Regular Expressions" for more detail.  (B)

	meta-insert-bindings (mib)  Controls behavior of 8-bit characters
		during insert.  Normally, key-bindings are only operational
		when in command mode: when in insert mode, all characters
		are self-inserting.  If this mode is on, and a meta-character
		is typed which is bound to a function, then that function
		binding will be honored and executed from within insert
		mode.  Any unbound meta-characters will remain self-inserting.
		(B)

	multibeep If a motion command fails, then vile, like vi, will
		normally sound the bell.  Turning this mode off prevents
		subsequent identical motion failures from also sounding the
		bell.  That is, if you repeat a failed motion many times
		(e.g. by holding down the backspace key), you only get one
		beep.  (U)

	newline (nl) The buffer ends with a newline.  This is set when reading
		a buffer.  (B)

	number	(nu) All lines in the buffer will be prefixed by their line
		number. (W)

	maplonger Controls whether the longer or shorter of two "nested"
		map strings will be favored by the editor.  When set, vile
		will match the longest available mapped string.  When reset,
		(the default) vile will match the shortest available map. (U)

	paragraphs A regular expression defining where the "next-paragraph"
		('}') and "previous-paragraph" ('{') commands will go. (B)

	popup-choices (pc) Must be set to one of the following three
		values: "off", "immediate", or "delayed".  When enabled
		with either "immediate" or "delayed", vile pops up the
		[Completions] buffer showing choices for filename and
		command completion in response to a TAB.  "immediate" will
		force the buffer to be popped up immediately if no progress
		is made in forming a completion.  "delayed" will cause vile
		to wait until TAB is pressed a second time before popping
		up the completion choices.  (U)

	popup-msgs (pm) When enabled, vile pops up the [Messages] buffer
		showing the text that was written to the message line.
		Closing the window clears its content until the next
		message is written.  This is most useful during the
		debugging of macros, since many messages may appear, each
		overwriting a previous one.  (U)

	printing-low The integer value representing the first of the
		printable set of "high bit" (i.e. 8-bit) characters.
		Defaults to 0.  Most foreign (relative to me!) users would
		set this to 160, the first printable character in the upper
		range of the ISO 8859/1 character set.  (U)

	printing-high The integer value representing the last character of
		the printable set of "high bit" (i.e. 8-bit) characters.
		Defaults to 0.  Set this to 255 for ISO 8859/1
		compatibility.  (U)

	remap   Controls whether :map or :map! sequences entered with
		no explicit remapping control should be subject to remapping
		(i.e. recursive mapping).  (U)

	remapfirst Controls whether the first character of a map expanded
		due to :map or :map! is eligible for remapping.  This is
		off by default for vi compatibility.

	report	A threshold value that is used to control messages that report
		the number of lines deleted, changed, etc.  (U)

	resolve-links Controls whether vile fully resolves file names in
		cases where some path components are symbolic links.  This
		makes vile smarter about symbolic links that provide
		multiple paths to a given file (preventing multiple
		unintentional edits of the same physical file via different
		pathnames).  It may trigger long timeouts on systems where
		symbolic links are used in conjunction with NFS automounted
		directories.  (Note that this does not detect or prevent
		multiple edits caused by hard file links -- only symbolic
		ones.) (U)

	ruler Shows the current line and column in the status line, as
		well as what percentage of the current buffer's lines lie
		in front of the cursor.  (This percentage is different than
		that given by ^G (the "position" function), which gives a
		percentage of characters rather than lines.) (B)

	samebangs (sb) Controls whether the ":!!" and "^X-!" commands
		remember the same command string.  (U)

	sections A regular expression defining where the "next-section" (']')
		and "previous-section" ('[') commands will go. (B)

	shiftwidth (sw) This is much like a tabstop, except that it is
		independent of hardware tabs and tab characters.  It is the
		number of columns a line will shift by if the '<<' or '>>'
		commands are used, and it chooses the next column stop for
		the cursor if a '^T' or '^D' is typed during insert mode. (B)

	showmatch (sm) During insert, if a closing "fence" character
		(usually '}', ']', or ')', but may be changed by setting
		"fence-pairs") is typed, the cursor will highlight the
		matching member of the pair for about a quarter second.
		(B)

	showmode (smd) Causes an indicator on the modeline to indicate what
		mode vile is currently in: insert (I), replace (R), or
		command (none).  (B)

	showram (sr) Displays the amount of ram currently allocated at the
		end of the message line. (not in all versions) (U)

	sideways  Will prompt for a new value for the sideways scroll offset,
		which allow display of a section of code normally off the
		screen to the right.  Also affected by the ^X-^R and ^X-^L
		commands.  (W)

	smoothscroll (ss) Force smooth scrolling.  By default, this option
		is turned off so that vile will try to keep up with your
		keystrokes instead of keeping the display up to date.  Some
		keyboards repeat faster than the screen can keep up causing
		the screen to jump.  If this bothers you, set smoothscroll
		to true.  Warning: If your keyboard repeats really fast and
		you have smoothscroll enabled, it may take a while for vile
		to catch up.  (U)

	tabinsert (ti) Allow the physical insertion of tab characters into
		the buffer.  If turned off ("notabinsert"), and an attempt
		is made to insert a tab character by explicitly typing it
		or by using shiftwidth or the line shifting commands, then
		the appropriate number of space characters will be inserted
		instead.  Use '^V^I' to insert a real tab, and remember
		that pre-existing tabs will not be affected.  Use the
		'^A-<SP>' operator command to eliminate pre-existing tabs
		from a region of text.  (B)

	tabstop (ts) Set the value for spacing of normal tabstops. (B)

	taglength (tl) Sets the significant length for tags.  If non-zero,
		lookups for names longer than the taglength value will only
		attempt to match that many characters.  If a lookup is for
		a shorter pattern, or the value of taglength is zero, then
		the tags must match the lookup pattern exactly.  This will
		not effect tags picked up from the cursor -- they are
		always matched exactly.  (B)

	tagrelative (tr) Causes files looked up via the tags mechanism to
		be found relative to the location of the tags file, rather
		than relative to the current directory. This allows the
		same tags file to be useful from different locations, while
		not requiring absolute filenames.  For example, using
		`set tags "tags ../tags"' would allow a single tags file
		(located in the parent) to be used in a small source
		hierarchy from either the parent or a child directory.  (B)

	tags	Gives a path of names of file(s) in which to look up
		tag references.  It is a whitespace-separated list of
		filenames.  Relative pathnames in this list are evaluated
		with respect to the current directory of vile at the time
		of the tags lookup.  (B)

	terse   vile produces more "status" messages than vi, which may
		become annoying at low baud rates.  Setting terse mode will
		suppress many of these.  (B)

	terse-selections (tsel)  Boolean indicating whether or not additional
		information is displayed about a selection.  When false, the
		starting and ending positions of the selection are displayed
		as the selection is extended.  The default is true. (W)

	timeoutlen  How long to wait for the characters of a :map'd sequence.
		Typically needed to resolve the ambiguity between a
		user-pressed ESCape key and an ESC character that is part
		of a function key sequence.  vile will wait for "timeoutlen"
		milliseconds after seeing an ESC, in order to check the
		next character of input.  The time defaults to 500, or half
		a second.  Users of fast local screens, like a local xterm,
		may wish to reduce this to something like 50 for crisper
		response to a user-pressed ESC.  (U)

	timeoutlen-user  If set non-zero, this will enforce a maximum
		waiting time for characters in a user-defined :map sequence.
		If zero, the value of timeoutlen, above, will be used for
		both "system" and user sequences.  It is likely that a
		short time is desired for system sequences, and a long time
		for user sequences.  For this reason the default value of
		timeoutlen-user is 60000.  This will give a full minute to
		type each character of a user-defined :map.  Be careful --
		extremely large values may overflow the word size on
		smaller machines, i.e, you will probably want to avoid
		setting timeoutlen-user larger than 65535.  (U)

	undolimit (ul) Sets a limit on how many undoable buffer-changing
		commands will be saved.  If set to 0, there is no limit,
		and all changes are undoable.  The default value is 10. (B)

	unprintable-as-octal (uo) If an 8-bit character is non-printing, it
		will normally be displayed in hex.  This setting will force
		octal display.  Non-printing characters whose 8th bit is
		not set are always displayed in control character (e.g. '^C')
		notation.  (B)

	view	View the file only.  No changes are permitted.  This is set
		automatically for the output of shell commands.  (B)

	view-on-readonly  Causes "view" mode to be set for read-only files. (U)

	visual-matches When a search command is executed, the cursor will
		move as usual.  In addition, all matching occurrences of
		the searched-for pattern (in the current buffer) will be
		emphasized according to the value of this mode: "none",
		"underline", "bold", "italic", or "reverse".  The '='
		command can be used to clear this sort of highlighting,
		until the next search is done for a different pattern.
		Note that setting this mode can significantly slow down the
		editor's operation when complex or frequently occurring
		patterns are used, since vile will need to scan the entire
		buffer for matches on any change to the buffer.  (B)

	warn-unread  When leaving the editor, if not all buffers have been
		"visited", then normally vile will complain, and remind the
		user to use ":q!".  Turning off "warn-unread" mode will
		suppress this behavior.  (U)

	working If turned off (noworking), will suppress the activity
		indicator ("working..."/"...working") which appears during
		long-running operations.  (U)

	wrapmargin (wm)  Implements vi's auto-wrap mode.  If nonzero, the
		wrapmargin specifies the number of columns on the
		screen's right margin to reserve before breaking the input
		lines on a preceding space.  (B)

	wrapscan (ws) Text searches will continue from past the bottom of
		the file to the top, and vice-versa.  (B)

	wrapwords (ww) Similar to vi's auto-wrap mode (i.e. "wrapmargin").
		While inserting, words are moved to the next line if the
		current line gets too long.  Unlike vi, wrapping is only
		attempted when a space is typed.  (B)

	xterm-mouse Enables mouse-clicking if you are running within an
		xterm.  That is, it allows vile to receive mouse events.
		Since this mode overrides xterm's cut & paste, you will
		need to use the Shift key when pressing the mouse buttons
		to cut and paste between X windows.  Your TERM variable's
		termcap entry must contain the string "xterm" for this to
		work.  (U)

8-Bit Operation
---------------

	vile allows input, manipulation, and display of all 256 possible
	byte-wide characters.  (Double-wide characters are not supported.)

	Output
	------
	By default, characters with the high bit set (decimal value 128 or
	greater) will display as hex (or octal; see "non-printing- octal"
	above) sequences, e.g.  \xA5.  A range of characters which should
	display as themselves (that is, characters understood by the user's
	display terminal) may be given using the "printing-low" and
	"printing-high" settings (see above).  Useful values for these
	settings are 160 and 255, which correspond to the printable range
	of the ISO-Latin-1 character set.

	Input
	-----
	If the user's input device can generate all characters, and if the
	terminal settings are such that these characters pass through
	unmolested (Using "stty cs8 -parenb -istrip" works for me, on an
	xterm.  Real serial lines may take more convincing, at both ends.),
	then vile will happily incorporate them into the user's text, or
	act on them if they are bound to functions.  Users who have no need
	to enter 8-bit text may want access to the meta-bound functions
	while in insert mode as well as command mode.  The mode
	"meta-insert-bindings" controls whether functions bound to meta-
	keys (characters with the high bit set) are executed only in
	command mode, or in both command and insert modes.  In either case,
	if a character is _not_ bound to a function, then it will be
	self-inserting when in insert mode.  (To bind to a meta key in the
	.vilerc file, one may specify it as itself, or in hex or octal, or
	with the shorthand 'M-c' where c is the corresponding character
	without the high bit set.

	(Although it is possible to edit and view all 256 characters, it is
	currently impossible to _search_ for a string that contains the NULL
	character, since this is used internally to terminate the search
	string.)

Command History
---------------

	You may scroll through the list of previous replies to the :-prompt
	by using the up- or down-arrow special keys on your keyboard (if
	your configuration supports it).

Special Character Expansion
---------------------------

	As in vi, the % and # characters typed while responding to a prompt
	will expand to the current or "alternate" filename.  In addition,
	the colon character (":") expands to the identifier name under the
	cursor.  Expansion of ! to the last command run is not implemented,
	except when a shell command is being entered.  These expansions can
	be suppressed by prefixing with a '\'.

Key Rebinding
-------------

	There is a key rebinding facility (if vile is built to include it),
	which is invoked as follows.  One must know the "english" name for the
	command being rebound.  Use ":list-commands" or ":apropos string"
	to find englishnames containing "string".  Then use the command:
		":bind-key englishname keyseq"
	where keyseq is the exact keyboard sequence (i.e. single character,
	or '^X', '^A', or '#' followed by a single character) to which the
	command should be bound.  In a .vilerc file, keyseq can be either
	the literal sequence, or the printable representation of the
	sequence, e.g. ^A-a or ^X-S.   (A summary of how key-sequences can
	be represented appears at the end of this section.)

	Commands can also be bound to meta keys, which are regular ASCII
	characters with the eighth bit (0x80) bit set.  The "printable"
	form for these keys is 'M-c'.

	Commands bound to '#-c' key sequences are usually also available
	by using the function keys on the terminal.  Thus the up-arrow
	function key can be bound to as '#-A'.

	Even the ^A and ^X prefix characters can be rebound, using the
	dummy functions "cntl_a-prefix" and "cntl_x-prefix", and the '#'
	key itself can be rebound -- it is represented by the command name
	"function-prefix".

	Examples:
	 To cause the / and ? commands to perform incremental
	  searches, use:
		bind-key incremental-search /
		bind-key reverse-incremental-search ?
	 To make ^N and ^P switch windows instead of cause motion by lines,
 	  try:
		bind-key next-window ^N
		bind-key previous-window ^P
	 To cause the space bar to move forward by pages, as in the "more"
	  command, use:
		bind-key next-page \s

	(Space and tab can be represented with: "\s" and "\t".)

	Note that when interactive, ^A and ^X are typed using the control
	key.  In a file, however, they can be either a caret (^) followed
	by a letter, or the literal control key.  In the latter case you
	would not use the '-' separator.  So ^A-x as four distinct
	characters could also be entered as ^Ax, which would only be two
	characters.

	Characters can be entered in hex or octal as well, in the form
	0xNN, where NN is exactly two hex digits.  So if you know the hex
	value for a key, you can bind to it like:
		bind-key next-window ^A-\x14
	or
		bind-key next-window #-\213

	The sequence 'M-', representing a "meta" character, is equivalent
	to setting the high bit of the following character, so 'M-e' is
	has the value of (0x80|0x65), or 0xe5.

	Function and meta key bindings are available in insert mode, as
	well as in command mode.  (But only via either the "meta bit" or
	ESC sequence form -- the '#' prefix will not work in insert mode.)
	So the following macro will work correctly in both command and
	insert modes:

		15 store-macro
			insert-string "fprintf(stderr, \""
			set-named-mark z
			insert-string "\\n\");\n"
			goto-named-mark-exact z
			; enter insert mode if we weren't already there
			~if &seq $mode "command"
				insert-chars
			~endif
		~endm
		; bind to function key f
		bind-key execute-macro-15 #-f
		; also bind to meta-A
		bind-key execute-macro-15 M-A


	Syntax for key-sequences:
	-------------------------
	To summarize, a key-sequence being bound to is specified with:
		1) an optional prefix, like this:
			^A-	(three chars)
			^X-	(three chars)
			^A	(one char)
			^X	(one char)

		2) followed by an optional "function" prefix:
			#-	(two chars)

		3) followed by an optional "meta" prefix:
			M-	(two chars)
			(this is the same as with specifying a character
			    in that has the high bit set)

		4) followed by a character, like this:
			C	(one char)
			^C	(one char)
			^C	(two chars)
			\NNN	(max of four chars, where NNN are octal digits)
			\xNN	(max of four chars, where NN are hex digits)
			\n,\r,\t,\b,\f,\a (two chars each, usual meanings)
			\e	(two chars, means ESC)
			\s	(two chars, means SPACE)

	(The "one char" control character entries in the above table are
	represented in this help file as two printable characters, to
	ensure they are not deleted by mailers or file transfer programs.)

	Function Keys
	-------------
	When you bind to a function key, you will see its value printed
	as a 'poundsign' sequence.  And, if you wish to :map a function
	key (see below), you will need to use its poundsign sequence.

	The list of function key labels, along with their "vile name",
	are as follows:

	   Usual Label    Vile name     Usual Label    Vile name
	   -----------    ---------     -----------    ---------
	    Up-arrow        #A          Home            #H
	    Down-arrow      #B          End             #E
	    Left-arrow      #D          Insert          #i
	    Right-arrow     #C          Delete          #d
	    Prior (PageUp)  #p          Find            #f
	    Next (PageDown) #n          Select          #s
	    Help            #?		Menu            #m
	    F1              #1          F12             #@
	    F2              #2          F13             ##
	    F3              #3          F14             #$
	    F4              #4          F15             #%
	    F5              #5          F16             #^
	    F6              #6          F17             #&
	    F7              #7          F18             #*
	    F8              #8          F19             #(
	    F9              #9          F20             #)
	    F10             #0          F11             #!
	    KeyPad_F1       #P          KeyPad_F3   #R
	    KeyPad_F2       #Q          KeyPad_F4   #S

	    In addition, #M, #t, and #T are used internally to support
	    mouse operations in an xterm.  To undo the relationship
	    between a "system-defined" function key and the poundsign
	    sequence it produces, use ":unmap-system-chars".


	:map, :map!, :noremap, :noremap!
	---------------------------------
	The vi "map" and "map!" commands are implemented in vile.  As in
	vi, mapping works best if the character sequence being bound
	corresponds to pressing a single key.  Multiple key sequences will
	work as long as the next key in the sequence is pressed within a
	specified number of milliseconds.  The value of "timeoutlen" is
	used for system-defined character sequences, i.e.  function keys.
	User defined sequences will use this too, unless the value of
	"timeoutlen-user" is non-zero, in which case this value will be
	used instead.

	Because "map" and "map!" may be used to remap arbitrary sequences,
	these sequences must be entered literally, i.e, the syntax for
	key sequences as listed above will not work for "map" and "map!".
	To enter control characters into a .vilerc file, use the ^V escaping
	mechanism.  A map command entered from the command line will require
	fewer characters be escaped with ^V.

	To provide a relatively portable way of specifying function key
	mappings, vile will reapply mapping to the result of a system-
	defined map.  System function keys are mapped to "poundsign"
	sequences, like '#1' for function key 1, and '#B' for the down-arrow
	key.  The remapping allows one to put
		map #1 <some-user-map-sequence>
	in the .vilerc file, and have the user-sequence executed when the
	system F1 key is pressed.  (Otherwise the terminal-specific
	sequence would have to appear in the .vilerc.)  See the section
	on "Function Keys" above for a full list.

	The "remap" option controls whether the successfully mapped result
	of a map is reevaluated for more mapping matches.  The "noremap" (and
	"noremap!") variants of the map commands will force that particular
	mapping to be applied without subsequent remapping, regardless of
	the current setting of the global "remap" setting.

	Long running loops caused by recursive :map definitions are
	detected and assumed to be infinite.  When an (assumed) infinite
	loop is detected, execution is aborted.  Turning off the "remap"
	option, or doing some of the maps with the ":noremap/:noremap!"
	form of the map commands will eliminate most such loops.

	Vile normally duplicates real vi's behavior (but not vim's) in that
	the first character of the sequence being mapped to is not subject
	to recursive (map) evaluation.  Assuming "remap" is on, pressing
	'j' when ":map j jh" is in effect will not cause an infinite loop,
	whereas ":map j hj" _wlll_ cause such a loop.  Setting the
	"remapfirst" option will allow this sort of remapping (and will
	cause an infinite loops for both examples).

	The "maplonger" option controls whether the longer or shorter of
	two "nested" map strings will be favored by the editor.  That is,
	if both "foo" and "foobar" are mapped (to presumably different
	values), then with "maplonger" set, vile will not expand "foo" until
	it is sure (either because the next character is not 'b', or a
	timeout has expired) that "foobar" will not be seen.  Real vi will
	always expand "foo" immediately, and this is the default behavior.
	Though not particularly recommended, the "maplonger" mechanism even
	permits the following types of mappings:

		:map z j
		:map zz k

	When 'z' is pressed by itself it will cause vile to move down one
	line (assuming j has not been rebound or remapped).  But if 'z' is
	pressed twice rapidly (enough) in succession, vile will move to the
	previous line.

	The left hand side of a map[!] definition may contain the usual
	backslash escapes:  \n, \r, \t, \b, \f, \a (^G), \e (ESC),
	\s (SPACE), \xNN (hex), \NNN (octal).  The right hand side is
	taken exactly literally, so special characters must be expressed
	as themselves.

	The current set of mappings or "map!"ings may be viewed with
	the commands ":map<CR>" (or ":show-mapped-chars") or ":map!<CR>"
	(or ":show-mapped!-chars").

	The system-defined maps, representing the function keys, may be
	shown with ":show-system-mapped-chars".

	To undo a mapping, use "unmap", "unmap!", or "unmap-system-chars".

	:abbr
	------
	The "abbr" command is also present in vile.  It is similar to, but
	slightly different than, "map!".  Whereas "map!" examines
	characters as they are typed, continuously looking for a match
	against the stored translation strings, the "abbr" command examines
	them after they are already in the buffer, and is more sensitive to
	their surrounding context.

	First, abbreviations are never expanded unless followed by
	non-"word" characters.  In addition, abbreviations which begin like
	a "word" (i.e. with letters, digits, or the '_' character) are not
	expanded if they immediately follow another "word" character --
	they must follow whitespace or punctuation or the beginning of the
	line.  Likewise, abbreviations that begin with a punctuation
	character are not detected within more punctuation -- they must
	follow whitespace or a "word", or the beginning of the line.

	If the "backspacelimit" setting is set (and it is, by default),
	then characters not inserted during the current insertion command
	are not considered in the above comparisons -- the start of the
	current insertion behaves much like the beginning of line in that
	case.

	Abbreviations are never recursive.

	vile is more lenient than vi regarding what is a valid
	abbreviation.  vi insists that an abbreviation be all "word"
	characters, or be all "non-word" characters, except for the last
	character, which _must_ be a "word" character.  vile allows
	anything at all to be abbreviated, only enforcing the expansion
	rules mentioned above.

	To undo an abbreviation, use "unabbreviate".

Special "Terminal" Key Rebinding
--------------------------------

	In addition to the above binding mechanism for vile commands, other
	keystrokes to the editor are rebindable using the "set-terminal"
	command.  These keystrokes are mostly derived directly from the
	user's tty settings on entering the editor, but there are a couple
	of additions related to command and filename completion.

	The values of these characters can be shown with the "show-terminal"
	command, and can be changed with the "set-terminal" command.

				Default value		Typical value
	-------------------------------------------------------------
	backspace		from tty settings	(DEL or ^H)
	interrupt		from tty settings	(^C or DEL)
	line-kill		from tty settings	(^U or @)
	name-complete		<tab>
	quote-next		from tty settings	(^V)
	start-output		from tty settings	(^Q)
	stop-output		from tty settings	(^S)
	suspend			from tty settings	(^Z)
	test-completions	?
	word-kill		from tty settings	(^W)

Flow-control
------------
	Historically, the flow of data between the computing host and the
	user's terminal was throttled through the use of special characters
	in the input stream, known as XON and XOFF (whose values are ^Q and
	^S respectively).  Most modern systems do not need these
	characters, and regulate the flow in an "out-of-band" manner.  The
	terminal device driver, however, is usually still set up with
	software flow control enabled, to allow the user to manually start
	and stop output with the ^S and ^Q characters.

	vile normally resets the driver to allow the ^S and ^Q characters
	to be bound to commands, since most systems no longer need software
	flow control, and since there is usually no reason for a user to
	wish to suspend output when running vile.  Some older devices
	(usually older slower terminals), however, still need to be able to
	automatically control the data flow by generating ^S/^Q without the
	user's intervention.

	To accomodate these situations, the "flow-control-enable" command
	will reset the terminal driver to its original state.  Software
	flow-control will be re-enabled, and commands bound only to the ^S
	and ^Q characters will be inaccessible.  The characters affected
	in this way may be seen with the "show-terminal-chars" command,
	where they will appear as the "start/stop-output" characters.
	The action of the "flow-control-enable" command will be reversed
	if it is given any argument.

Recorded macros
---------------

	The first type of macro in vile is for temporary, quick macro
	usage, and lets you record a macro as you execute vile commands.
	You can then replay those keystrokes with a single key.

	^X-(	Begin recording a keyboard macro.  The keystrokes you type
		are recorded, until you use ^X-).
	^X-)	Finish recording a keyboard macro.
	^X-&	Execute the keyboard macro.

	The vi '@' command is present as well, and can be used to execute
	the contents of a named register as if it were entered at the
	keyboard.  To make this more useful, the "load-register" command
	will allow preloading a named register, from .vilerc file.  For
	example:
		use-register a load-register ihello^[
	will load register 'a' with a command to insert the word "hello".
	(The ^[ should be a real ESC character, entered by preceding it
	with ^V.)  A better example, is this:
	    use-register w load-register ":!chmod +w %^M:w^M"
	which makes the current file writable and writes it.  (Again, use
	^V to get the CR characters into the .vilerc file.)

Programmed procedures and macros
--------------------------------

	[ For more/different information on programmed macros, refer
	to the file "macros.doc", supplied with the vile source code. ]

	vile can also be extended by defining macros and then binding
	the execution of those macros to key sequences.  For instance, if
	the following lines appear in a .vilerc file:
		1 store-macro
		 5 delete-til next-word
		~endm
		bind-key execute-macro-1 ^A-1
	then when ^A-1 is executed, 5 words will be deleted.  The "-til"
	suffix on an englishname denotes that it is a vi operator style
	command, and expects to be followed by a motion command.  Also,
		1 store-macro
		 5 delete-til lines
		~endm
	would be the equivalent of "5dd" since the word "lines" represents
	the stuttered 'dd' style of operation.  More examples are given
	down below.

	Variables
	---------
	There are some built-in variables that can be used in macros to gain
	access to parts of vile status, and parts of the current buffer.
	Built-in variables are accessed by name, prefixed with the '$'
	character.  There are two types of built-in variables (the environment
	variables, and mode values).  The environment variables are:

	$abufname	alternate buffer name (i.e. last visited)
	$buffer-hook	name of procedure to run when switching to a buffer
	$cbufname	current buffer name
	$cd-hook	name of procedure to run when changing directories
	$cfilname	current file name
	$char		character under the cursor
	$curcol		current column position of cursor
	$curline	current line in file
	$cwd		current directory
	$cwline		line offset in current window
	$debug		macro debugging -- set true for line by line tracing
	$directory	controls location of temp-files
	$discmd		display commands on command line
	$disinp		display command line input characters
	$exit-hook	name of procedure to run when quitting
	$flicker	set true to suppress CGA flicker on a PC.  ugh.
	$font		current font name (X11 version only)
	$iconname	current icon name (X11 version only)
	$identifier	current punctuated word
	$kill		some of the kill register		(read only)
	$lastkey	last keyboard char struck
	$line		text of current line
	$llength	length of current line			(read only)
	$match		last matched magic pattern		(read only)
	$mode		current mode ("command","insert","overwrite") (rd. o.)
	$modeline-format format of mode lines.  see "Mode line customization".
	$modified	is current buffer modified or not?
	$ntildes	percent of window filled by ~ chars, at end of buffer
	$ocwd		previous directory			(read only)
	$os		operating system ("unix", "dos", "vms", "os/2") (rd. o.)
	$pagelen	number of screen lines in use by editor
	$pagewid	current screen width
	$palette	current palette string
	$pathname	current path-like word
	$pending	typeahead pending flag			(read only)
	$pid		returns vile's process-id
	$progname	returns "vile" or "xvile". (read-only)
	$qidentifier	current qualified name (as with C++ ::)
	$read-hook	name of procedure to run after a file is read
	$replace	replacement pattern
	$search		search pattern
	$seed		current random number seed
	$shell		name of the shell program for spawned commands.
	$sres		current screen resolution
	$status		returns the status of the last command
	$title		current window title (X11 version only)
	$tpause		length to pause for paren matching (PC versions)
	$version	current version number			(read-only)
	$wline		number of lines in current window
	$word		current "word"
	$write-hook	name of procedure to run before a file is written

	In addition to the environment variables, you may set and use the
	values of the editor modes (i.e., universal modes, buffer-only modes or
	window-only modes), e.g., "setv $dos=true".  The global values of the
	editor modes are not visible to the expression evaluator.

	User-defined variables can also be set and used; their names are
	prefixed with the '%' character.

	Response variables (a '@' followed by a prompt-string) cause vile to
	prompt for input with the given prompt-string.

	Buffer variables (a '<' followed by a buffer name) return the current
	line of the specified buffer, automatically setting the position to the
	next line.

	Functions
	---------
	There are also functions available, which can act on those variables,
	or on hard-coded values.  Operations are expressed in prefix notation,
	so to add to numbers you would say "&add 3 5".

	func	no. of
	name	args
	--------------
	&add	2	add two numbers together
	&sub	2	subtraction
	&tim	2	multiplication
	&div	2	division
	&mod	2	modulus
	&neg	1	negate
	&cat	2	concatenate string
	&lef	2	left string(string, len)
	&rig	2	right string(string, pos)
	&mid	3	mid string(string, pos, len)
	&not	1	logical not
	&equ	2	logical equality
	&les	2	logical less than
	&gre	2	logical greater than
	&seq	2	string logical equality check
	&sle	2	string logical less than
	&sgr	2	string logical greater than
	&ind	1	evaluate indirect value
	&and	2	logical and
	&or 	2	logical or
	&len	1	string length
	&upp	1	uppercase string
	&low	1	lower case string
	&tri	1	trim whitespace from string
	&tru	1	Truth of the universe logical test
	&asc	1	char to integer conversion
	&chr	1	integer to char conversion
	&gtk	0	get 1 character
	&rnd	1	get a random number from 1 to n
	&abs	1	absolute value of a number
	&sin	2	find the index of second string in first
	&env	1	retrieve a system environment variable
	&bin	1	lookup what function name is bound to key
	&rd	1	is a file readable
	&wr	1	is a file writable
	&glo	1	retrieves global mode setting
	&loc	1	retrieves local mode setting


	Directives
	----------
	Primitive flow-of-control within a macro may be obtained with
	certain directives.  Macro directives start with a "~" and include
	the following:  (see the file macros.doc for more detail)

	~if cond	conditional execution
	~else
	~endif
	~return		Return (terminating current macro)
	~goto *label	Jump to a label in the current macro
	~force		Force macro to continue...even if command fails
	~while cond	Execute a loop if the condition is true
	~break
	~endwhile

	~endm		End a macro

	Line Labels begin with a "*" as the first nonblank char, like:

	*LBL01

	Procedures vs. Macros
	---------------------
	Macros are really just a special use of stored "procedures", which
	are, in turn, really just a special "type" of buffer.  To execute
	the contents of a buffer, it needs to have a name of the form
	"[buffername]".  Then, it can be executed as a procedure with the
	"run" command, as in "run buffername".  The best way to get
	procedures into buffers named that way (and also to make them
	invisible, so they don't clutter the buffer list) is to use
	the "store-procedure" command:

	    store-procedure my_cd_action
		write-message &cat &cat &cat "moved from " $ocwd " to " $cwd
		~if &seq $progname "xvile"
		    set title $cwd
		~endif
	    ~endm

	Macros are a special usage of procedures, which are bindable to
	keystrokes (i.e. if procedures could be bound directly to keys,
	then macros would be redundant).  When the "9 store-macro" command
	is used, it creates a procedure whose name is [Macro 9], where 9
	is the argument to "store-macro".  This can then be executed
	with either
		run "Macro 9"
	or
		execute-macro-9
	Most of the examples given below use the macro form of definition,
	since one most often wants to bind macros to keys.

	Hooks
	-----
	There are a few places within vile where a user-specifiable
	procedure will be executed if desired.  These points are referred
	to as "hooks".  Hooks are specified by special variables which
	hold the name of a procedure to run at that point in the code.
	For instance, there is a "cd-hook", which is run when you change
	directories.  So, using the "my_cd_action" example given above,
	if the line
		set cd-hook my_cd_action
	is added, then that procedure will print a message and, under
	xvile, change the window title when the current directory is
	changed.

	The following hooks are currently implemented:
	$buffer-hook	run when switching to a buffer
	$cd-hook	run when changing directories
	$exit-hook	run when quitting
	$read-hook	run after a file is read
	$write-hook	run before a file is written

	Be careful with "buffer-hook".  Executing commands in the hook
	which themselves switch buffers is not recommended.  In general,
	all the hooks are a little dangerous, since vile has not been
	written with re-entancy foremost in mind.  One should avoid putting
	actions in hooks which might cause the hook to be re-executed.
	(vile keeps the hook procedure itself from being re-executed, to
	prevent recursion, but the code surrounding the call to it may not
	be safe either.)

	Macro examples
	--------------
	To prevent vile from thinking that a failed command is an error in
	the macro, you can put "~force" in front of it.  So, to write a
	macro which will run the "man" command on the identifier under the
	cursor, where you don't really consider it an error if the command
	fails, you might use:

		9 store-macro
			~force 1 shell-command &cat "man " $identifier
		~endm
		bind-key execute-macro-9 ^X-m

	(The argument '1' suppresses the "press return" prompt which
	normally appears after a command runs, since man runs a pager
	which does this anyway.)

	The "screen-search-forward" command could be re-implemented as:
		10 store-macro
			~force search-forward $identifier
		~endm
		bind-key execute-macro-10 ^X-/

	And the "screen-search-pattern-grab" command, normally bound to
	^A-/, could be implemented with:
		11 store-macro
		    set-variable $search $identifier
		    write-message &cat "Search pattern is now " $search
		~endm
		bind-key execute-macro-11 ^A-/

	A variation, which will not find the identifier if it is a substring
	of another word, is:
		12 store-macro
			~force search-forward &cat "\\<" &cat $identifier "\\>"
		~endm
	This works by surrounding the string with the \< and \> meta-characters.


	Here's another example, which finds C++ qualified identifiers, and
	uses them for a tag lookup:
		* Implement  ^A-^] for qualified-name tag lookup
		24 store-macro
			backward-character
			set-variable %osearch $search
			search-forward "^[a-zA-Z_][a-zA-Z0-9_:]*"
			set-variable $search %osearch
			set-variable %osearch ""
			write-message &cat "Tag pattern is now " $match
			~force find-tag $match
		~endm
		bind-key execute-macro-24 ^A-^]
	(The "backward-character" is needed because "search-forward" will
	always skip the cursor position when scanning, so as to always find
	the next occurrence.  The user variable %osearch is used so as not
	to disturb the search string.)

	Note that for simple key-remappings, binding is often preferable
	to creating a macro.  Some people prefer using lower-case 'g' to
	as an equivalent to 'G', to goto a specific line.  If done as a
	macro, like this:

		3 store-macro
		    goto-line
		~endm
		bind-key execute-macro-3 g

	then both g and G go to the end of the file, but whereas 1000G goes
	to line 1000, 1000g goes to the end of the file 1000 times.  It is
	easier (and more correct) to do:

		bind-key goto-line g

	A couple more examples of slightly more complex macros:
	They cause a jump to the next (or previous) line of the same (or
	lesser) indent, skipping over empty lines.  (Thanks to MIURA Masahiro)

	; macro 1 - back to the line of same indent
	;
	1 store-macro
		first-nonwhite
		set-variable %indlev $curcol
		~force back-line-at-bol
		~if &equ $llength 0
			~goto L1
		~endif
		~while &les %indlev $curcol
			*L1
			~force back-line-at-bol
			~if &seq $status "FALSE"
				~return
			~endif
			~if &equ $llength 0
				~goto L1
			~endif
		~endwhile
	~endm
	bind-key execute-macro-1 ^X-[

	; macro 2 - forward to the line of same indent
	;
	2 store-macro
		first-nonwhite
		set-variable %indlev $curcol
		~force down-line-at-bol
		~if &equ $llength 0
			~goto L2
		~endif
		~while &les %indlev $curcol
			*L2
			~force down-line-at-bol
			~if &seq $status "FALSE"
				~return
			~endif
			~if &equ $llength 0
				~goto L2
			~endif
		~endwhile
	~endm
	bind-key execute-macro-2 ^X-]

	; macro 14 - grep for the word under the cursor, and put the result
	;	in a buffer named after that word.  set the error-buffer,
	;	so that ^X-^X may be used to visit the lines found by grep.
	;	(we have to set error-buffer explicitly, since we renamed
	;	the buffer -- otherwise it tracks the last pipe read by vile)
	14 store-macro
		set-variable %grepfor $identifier
		edit-file &cat "!egrep -n " &cat %grepfor " *.[chs]"
		rename-buffer %grepfor
		error-buffer %grepfor
	~endm
	bind-key execute-macro-14 ^A-g

	As a hint, it is (almost?) never correct to write a ':' command
	when creating a programmed macro.  For instance, if you find
	yourself writing something like:

	    &cat ":!chmod +w " $cfilname
	    &cat ":e! " $cfilname

	(in an attempt to make a buffer writable before editing it), then
	what you really want is:

	    shell-command &cat "chmod +w " $cfilname
	    replace-with-file $cfilname

	Furthermore, some things are just as easy if done with a
	"keystroke" macro rather than a programmed macro:

	    ; use this as '@w'
	    use-register w load-register ":!chmod +w %^M:setl noview^M:w^M"

	or

	    map ^A-w ":!chmod +w %^M:setl noview^M:w^M"

	(Of course you need to replace the ^M's with real carriage-returns.)

	Picture Mode
	------------
	Another example of a fairly complex vile procedure can be found
	in the file "pictmode.rc".  The code there implements a primitive
	means of drawing "ASCII art":

		o----------------------------------------o
	       /----------------------------------------/|
	      o----------------------------------------o||
	      | To use it, first ":source pictmode.rc" |||
	      | and then "run pic".  See the comments  |||
	      | at the top of pictmode.rc for more     ||o
	      | information...			       |/
	      o----------------------------------------o

Regular Expressions
-------------------

	Searches use regular expressions, which, as in vi, may be magic
	by default or not.

	vile introduces some new magic metacharacters.

	The code that implements the expressions is based directly on
	Henry Spencer's regexp code.  Quoting from the original man page:

	[For ease of reference, the metacharacters are noted in the margin.)

   \|	"A regular expression is zero or more branches, separated by `\|'.
	It matches anything that matches one of the branches."

	"A branch is zero or more pieces, concatenated.  It matches a match
	for the first, followed by a match for the second, etc."

	"A piece is an atom possibly followed by `*', `\+', or `\?'.  An atom
   *	followed by `*' matches a sequence of 0 or more matches of the
   +	atom.  An atom followed by `\+' matches a sequence of 1 or more
   \?	matches of the atom.  An atom followed by `\?' matches a match of
	the atom, or the null string." [i.e., `\?' matches 0 or 1 occurrences]

 \( \)	"An atom is a regular expression in backslashed parentheses
	(matching a match for the regular expression), a range (see below),
  . ^	`.' (matching any single character), `^' (matching the null string
   $	at the beginning of the input string), `$' (matching the null
   \c	string at the end of the input string), a `\' followed by a single
   c	character (matching that character), or a single character with no
	other significance (matching that character)."

 \< \>	In addition, vile atoms may be: \< and \>, which match the
 \s \S	beginning and end of a "word", \s and \S, which match characters of
 \w \W	whitespace and "darkspace", \w and \W, which match alphanumerics
 \d \D	(including '_') and non-alphanumerics, \d and \D, which match
 \p \P	digits and non-digits, and \p and \P, which match printable and
	non-printable characters (whitespace is printable).

 [ ]	"A range is a sequence of characters enclosed in `[]'.  It normally
	matches any single character from the sequence.  If the sequence
	begins with `^', it matches any single character not from the
	rest of the sequence.  If two characters in the sequence are
	separated by `-', this is shorthand for the full list of ASCII
	characters between them (e.g.  `[0-9]' matches any decimal digit).
	To include a literal `]' in the sequence, make it the first
	character (following a possible `^').  To include a literal `-',
	make it the first or last character."

	Additionally for vile, if "ignorecase" is set, then all literal
	matches, including those in character classes, are done without
	regard to upper and lower case.

	In magic mode, the following set of metacharacters
	must be preceded by '\' to hide their special meaning:
		* [ . ^ $
	These characters are special if they _are_ preceded with a '\':
		? + ( ) | < >

	If magic mode is _not_ on, only ^ and $ are special if not escaped.
	All of the following must be preceded with a '\' to be special,
	otherwise they are taken literally:
		? + ( ) | * [ . < >

	Replacement subexpressions are supported when substituting.  That
	is, if part of an expression is contained in \( and \), then the
	part of the matched text in between those symbols will be
 \1 \9	substituted for an occurrence of \1 in the replacement pattern.  Up
	to 9 such substitutions can be made.  The special symbol & will
  &	substitute for the entire match string.

	The replacement part of the substitution may also contain the
 \U \L	special sequences \U and \L, which cause the replacement to be
 \E	forced to uppercase or lowercase until a terminating \E is found;
 \u \l	\u and \l, which force the case of a single character; and \b,
 \bfrtn	\f, \r, \t, \n, which insert the usual ASCII character.
	Note that vile mimics perl's handling of \u\L\1\E instead of vi's.
	Given :s/\(abc\)/\u\L\1\E/ vi will replace with "abc" whereas vile
	and perl will replace with "Abc".  This is somewhat more useful for
	capitalizing words.

Command files
-------------

	On startup (in the absence of '@' arguments -- see Invocation
	below), vile will attempt to read the file ".vilerc" in the current
	directory, and then in $HOME, and will execute the commands found
	therein.  [This file is called "vile.rc" under DOS, and is searched
	for in the current directory and along the PATH.]  It is possible to
	nest such executions.  For example, you might keep your general
	default settings in your home directory, and put the following
	lines in a .vilerc in a directory in which you prefer tabs be set
	to 4 spaces:

		source "$HOME/.vilerc"
		set tabstop 8

	The quotes surrounding the filename are necessary to protect the
	name from interpretation as a vile variable, since it starts with
	the '$' character.

	Files can be executed at any time with the ":source" (or
	":execute-file") command.  There are control structures available,
	such as ~while, ~if, etc.  Refer to the file macros.doc which
	is distributed with vile for more information.

	Nesting of source'd files is limited to a depth of ten, to prevent
	infinite recursion.

	The ';' character can be used as a comment character in command
	files, but not necessarily on the same line as valid commands.  Put
	your comments on separate lines to be safe.

Invocation
----------

	As mentioned above, vile normally looks for files called "./.vilerc"
	and "$HOME/.vilerc", and executes the first one found.  If the
	variable VILEINIT is set in the environment, it is used as a set of
	vile commands to initialize the editor.  As a not-very-useful
	example of a VILEINIT sequence, the following setting will exactly
	recreate the default (i.e. no VILEINIT variable) behavior:

		export VILEINIT
		VILEINIT="
		~if &rd \"./.vilerc\"
			source \"./.vilerc\"
		~else
			~if &rd \"$HOME/.vilerc\"
				source \"$HOME/.vilerc\"
			~endif
		~endif"


	Command line options
	--------------------
	The command line options are fairly straightforward.  vile does not
	support running just _any_ command after a '+', as does vi, but does
	support the commonly used '+400' to go to line 400 and '+/foo' to
	search for foo.  Command files can be explicitly executed on
	startup by prefixing them with the '@' character, as in "vile
	@mycmds file.c".  This will suppress the operation of VILEINIT and
	the .vilerc files.

	Use "vile -?" to get the usage message.

	+NNN and -gNNN  vile will begin the session on the first file
		at the specified line number.

	+/pattern or -s pattern   In the first file, vile will execute an
		initial search for the given pattern.

	-t tag  vile will edit the correct file and move the cursor
		to the location of the tag.  This requires a tagsfile
		created with the ctags(1) command.

	-h      Invokes vile on the helpfile.

	-v	Invokes vile in "view" mode - no changes are permitted
		to the buffer in this mode.  (This will also be true if
		vile is invoked as view.)

	-V	vile will report its version number.

	@cmdfile   vile will run the specified file as its startup
		file, and will bypass any normal startup file (i.e.
		.vilerc) or environment variable (i.e. $VILEINIT).

Crash Recovery
--------------

	The "vi -r" option, used to recover an edited buffer after a system
	crash, is not present in vile.  If vile itself crashes (usually
	(though infrequently :-) due to a bug, but perhaps due to an
	externally applied signal), it will attempt to save any modified
	buffers in a directory under /tmp, and send mail to the user to
	that affect.  If system crashes are frequent on your system, you
	should stop using it.  You might also consider the "autosave" and
	"autowrite" options, which will cause more frequent saves of your
	work.


Mode line customization
-----------------------

	At the bottom of each window is a mode (or "status") line which
	is used for displaying certain characteristics of the window and
	the buffer associated with it.  On most displays, this mode line
	will be highlighted in reverse video or via other means in order
	to visually separate windows and to distinguish the mode line from
	text displayed in the window.

	The editor variable "modeline-format" is set to a string which
	controls formatting of mode lines.  This variable is user settable and
	thus may be used to customize the display of mode lines.  The
	format specifiers which may appear in the format control strings
	are as follows:

		%i 	insert/overwrite/replace mode indicator, displayed
			only when in insert, overwrite, or replace mode.
			When not in one of these modes, the separator
			character (often "-", "=", or " ") will be displayed.
		%b	buffer name
		%f	file name when not internal buffer and when not the
			same as the buffer name.
		%F	internal buffer name
		%m	major mode(s), e.g, cmode, view-only, etc.  Displayed
			in square brackets.
		%l	line number to be displayed if "ruler" is set
		%c	column number if "ruler" is set
		%p	line number as percentage of number of lines if
			"ruler" is set
		%S	rough position of window with respect to buffer (top,
			bot, all, emp, mid) when ruler not set (or ruler is
			set, but buffer is empty).
		%L	number of lines in buffer, if ruler is set
		%=	middle separator; should appear at most once in a
			format string.  This indicates where to separate the
			left and right hand portions of the mode line with a
			long string of dashes (or whatever the separator
			character is).
		%-	single occurrence of separator character
		%|	eighty column indicator
		%%	percent sign
		%:	colon

	Some of the format specifiers (%f, %F, %m, %l, %c, %p, %S, %L) are
	conditionally displayed.  For example "%m" will display the major
	modes only if there are some major modes set or if the buffer has
	been modified (which is sort of a major mode).  Similarly, "%F" and
	"%f" will cause the associated file name to be displayed when the
	buffer is of the appropriate type (a scratch buffer or not) and the
	shortened file name is different from the buffer name.  It is
	desirable at times to cause a prefix string and/or a suffix string
	to be emitted along with the string obtained after conversion of
	the format specifier.  This may be done by following the format
	specifier with a colon, the prefix string, another colon, the
	suffix string, and another colon.  For example, "%l:(:,:%c::) :"
	might be used to display the line and column number for "ruler"
	mode.  Note that either or both of the prefix and suffix strings
	may be empty.

	Characters in the string which are not part of a format specifier
	are output verbatim.

	The default format control string is as follows:

	    "%-%i%- %b %m:: :%f:is : :%=%F: : :%l:(:,:%c::) :%p::% :%S%-%-%|"

	Mode lines for some versions of vile previous to version 4.7 can be
	obtained with the following format string.  This will remove the
	percentage indication from the mode line when in ruler mode and
	also shift the ruler indicator to the far right in the mode line.

	    "%-%i%- %b %m:: :%f:is : :%=%F: : %-%-%-%-:%l:(:,:%c::):%S::%-%-:%|"

Filtering "man" pages
---------------------

	When used in conjunction with the vile-manfilt program (supplied as
	source file "manfilt.c"), either vile or xvile may be used to filter
	and view manual pages.  xvile will even display (with your font set
	properly) certain portions of the manual page text in bold or
	italics as appropriate.

	The file manpage.rc (found in the vile source directory, and also
	copied below) contains a macro which is bound to ^X-m.  It will
	prompt for a manual page, filter it, attach attributes and display
	it in the current window.  The text of manpage.rc may be either
	incorporated verbatim into your .vilerc file or may be read from
	your .vilerc as follows:

		source ~/manpage.rc

	This assumes that you have moved the manpage.rc file to your home
	directory.  If you do all of this but use vile rather than xvile,
	you will still end up with a legible man page, albeit without the
	spiffy formatting.

	The manual page filtering program may also be used to look at other
	text formatted with nroff.  From the vile source directory, for
	example, the following command will format and filter the vile
	manual page (which is nroff source).

		:e !nroff -man vile.1 | vile-manfilt

	Once loaded, it will look rather funny.  There will be Cntl-A
	characters scattered throughout the text followed by a sequence of
	digits followed by one or more uppercase letters followed by a
	colon.  These Cntl-A sequences specify how the text following the
	colon should be attributed.  The vile command
	"attribute-cntl_a-sequences-til" (bound to ^A-A) may be used to
	format a region of text containing these sequences.  To continue our
	example, the following command will translate this representation of
	attributed text into one which is more pleasing to look at.

		^A-AG

	Here is the macro from the file manpage.rc:
	;;
	;; Macros for obtaining manual pages and then attributing them.
	;;
	;; Author: Kevin Buettner

	29 store-macro
		set-variable %manpage @"man page? "
		~if &or &seq %manpage "ERROR" & seq %manpage ""
			~return
		~endif
		set-variable %manpagebuf &cat "<" &cat %manpage ">"
		set terse
		~force select-buffer %manpagebuf
		~if &not $status
			edit-file &cat "!man " &cat %manpage " | vile-manfilt"
			~force rename-buffer %manpagebuf
			~force error-buffer %manpagebuf
			write-message "[Attaching attributes...]"
			goto-beginning-of-file
			setl noview
			attribute-cntl_a-sequences-til end-of-file
			unmark-buffer
			setl view
			goto-beginning-of-file
			write-message "[Done formatting manual page.]"
		~endif
		set noterse
	~endm
	bind-key execute-macro-29 ^X-m

Filtering C programs
--------------------
	C program text may be displayed with keywords and comments
	highlighted in a similar fashion to the man page filtering
	described above.  A filter which performs this is supplied with
	vile, and is called "vile-c-filt" (source is "c-filt.c").  Its use
	is described more fully in comments at the head of the source file.
	It doesn't provide what one would describe as "tightly integrated
	syntax coloring".  Its usefulness is limited by reliance on an
	external filter to do the coloring, and the fact that the filter
	interferes with the normal undo history of the buffer (since it
	must modify the buffer to do its work).  Nonetheless, it's an
	interesting adjunct to the editor.

	Here is a macro one might use to invoke the colorizer:
	    30 store-macro
		    write-message "[Attaching C/C++ attributes...]"
		    set-variable %savcol $curcol
		    set-variable %savline $curline
		    set-variable %modified $modified
		    goto-beginning-of-file
		    filter-til end-of-file "vile-c-filt"
		    goto-beginning-of-file
		    attribute-cntl_a-sequences-til end-of-file
		    ~if &not %modified
			    unmark-buffer
		    ~endif
		    %savline goto-line
		    %savcol goto-column
		    write-message "[Attaching C/C++ attributes...done ]"
	    ~endm
	    bind-key execute-macro-30 ^X-q

	The vile-c-filt program does its work based on the contents of
	$HOME/.vile.keywords, which contains a set of keyword/attribute
	pairs.  An example (and probably insufficient) .vile.keywords file
	might contain:
		Comments:B
		Literal:B
		#if:U
		#else:U
		#endif:U
		#define:U
		if:C3
		else:C3
		for:C3
		while:C3
		do:C3
		typedef:I
		struct:I
	(The "Comments" keyword is a pseudo-keyword which determines the
	attribute given to C and C++ style comments.  "Literal" applies to
	string literals.)

	An alternative filter, written using "flex", is available in
	c-filt.flx.  It might suit your needs better, or be a better
	starting point for creating similar coloring mechanisms for other
	languages.

X Window System specifics
-------------------------

	If you are using xvile under X11, the following additions are
	available:

	Mouse buttons
	-------------

	1 -	Sets cursor position and the start of the selection when
		mouse pointer is positioned in any vile window (but not the
		message line).	Clicking on a mode line will set the
		keyboard focus to the corresponding vile window.  Double
		clicking on a mode line will do the above in addition to
		clearing the highlighting associated with the current
		selection.

		Selections may be made by holding button one down and
		"wiping" with the mouse.  Release of the mouse button will
		cause the selection to be yanked and made available (if
		desired) for pasting.  The region selected may be forced to
		be rectangular by holding the control key down while wiping
		with button one depressed.  If the wiping motion goes out of
		the current window, text will be scrolled in the appropriate
		direction if possible to accomodate selections larger than
		the window.  The speed at which the scrolling occurs will
		increase with the passage of time making it practical to
		select large regions of text quickly.

		Individual words or lines may be selected by double or
		triple clicking.

	2 -	Paste the current PRIMARY selection.  With a modifier, it
		pastes at the mouse position, otherwise it pastes at
		the text cursor position.

	3 -	Extend the current selection.  As with button one, the
		selection may be adjusted or scrolled by holding down button
		three and wiping with it.  Selections may be extended in any
		window open to the same buffer as which the selection was
		started in.

	[ As described below in the "Scrollbars" section, the buttons
	are modified by the control key as follows, when used on a scrollbar:

	Ctrl-Button-1 splits the clicked-on window into two windows.
	Ctrl-Button-2 deletes the clicked-on window.
	Ctrl-Button-3 makes the clicked-on window the only window. ]


	Areas of selected text can be operated on with any vile operator
	command, in conjunction with the special "motion" command '^S',
	which applies the operator to the selected region.  For example,
	after selecting text with the mouse, it can be converted to
	uppercase with ^A-u^S.	Remember that some operators (e.g. the
	shell-filtering operator, '!') are only capable of working on full
	lines of text.

	Scrollbars
	----------

	The X toolkit version of xvile provides default translations
	similar to the translations for scrollbars found in the Athena
	widget set.  (If you know how to use xterm's scrollbars, you know
	how to use these scrollbars.)  Button one scrolls forward.  Button
	three scrolls backward.  The amount of scrolling obtained by these
	buttons depends on the position at which they were pressed on the
	scrollbar.  Clicking near the top of the scrollbar will scroll the
	text by a small amount which may be as little as one line.
	Clicking in the middle will scroll by about half a page.  Clicking
	near the bottom will scroll by a larger amount up to a whole page.
	Holding either one of these buttons down will cause repeated
	scrolling.

	If simply pressed and released, button two will set the position in
	the buffer to a position proportional to the location of the
	pointer on the scroll bar.  Button two may be held down to "drag"
	the slider from one place to another causing text to scroll
	continuously.

	The Motif and Openlook versions provide scrollbars from their
	respective widget sets.  Both versions have a slider indicating the
	position of the window over the buffer.  OpenLook's slider is fixed
	in size with little arrows at the top and bottom of the slider.
	Pressing on one of these arrows will cause scrolling in the
	appropriate direction.	The slider may be "grabbed" and moved by
	pressing and dragging the middle portion between the arrows.
	Motif's slider is solid with size varying to indicate the size of
	the window with respect to the size of the buffer.  Any portion of
	it may be grabbed for movement.  There are little arrows at the top
	and bottom of the scroll bar which may be clicked upon to cause
	scrolling by one line.	In both of these widget sets, clicking on
	the scrollbar either above or below the slider will cause scrolling
	by a full page.  OpenLook has two additional control areas; the
	buffer position may be set to either the beginning or end of the
	buffer by pressing on one of the little rectangular areas at either
	the top or bottom of the scrollbar.

	In all versions built with scrollbars enabled, you can resize
	windows by moving the border between corresponding scrollbars (with
	the mouse).  The X toolkit version is probably the most functional,
	with the windows being continuously resized as the mouse is moved.
	The OpenLook and Motif versions wait until after a position is
	selected to resize the windows.  The OpenLook version is perhaps
	the least functional; there is no visible indication (other than
	the position of the mouse pointer) to indicate where the new border
	will be.

	Splitting and deleting of windows may also be done with the mouse.
	In each case the action is selected by pressing one of the mouse
	buttons over a scrollbar with the control key held down.  Button
	one (with the control key held down) will split the scrollbar and
	the corresponding vile window with the new border at or near the
	mouse cursor.  Button two (with control key) will delete the
	scrollbar and corresponding window.  Button three (with control
	key) will make the corresponding window the only window.

	Standard X command line arguments
	---------------------------------

	-fn fontname	Font to use (or -font).
	-rv		Use reverse video (also -reverse).
	+rv		Don't use reverse video.
	-display disp	Display to run xvile on.
	-fg color	Foreground color (or -foreground).
	-bg color	Background color (or -background).
	-bd color	Border color (or -bordercolor).
	-name name	Name used for resource lookups.
	-title name	Name to be displayed in titlebar.
	-geometry geom	Initial window dimensions in columns and rows.
	-iconic 	Start xvile iconified.
	-xrm Resource	Specify or change an X resource internal to xvile.

	Additional xvile command line arguments
	---------------------------------------

	-leftbar	Put scrollbar(s) on left.
	-rightbar	Put scrollbar(s) on right (default).

	Setting a new process group
	---------------------------
	Some systems and/or some shells and display managers seem to want
	xvile to run in its own process group, to help isolate its signals
	and actions from the signals and actions of the parent process
	(i.e. the shell or window manager that starts xvile).  xvile can
	be forced into its own process group with the "new-process-group"
	command, which one would put in the .vilerc file.  Using this will
	cause a call to "setpgrp()" or "setsid()".  This behavior is not
	the default because a) it can't be undone, and b) it seems
	undesirable on some systems, in that xvile cannot be suspended and
	put in the background after startup if it's in its own group.

	Additionally, if given a count as argument, this command will cause
	xvile to fork(), and the parent to exit before the new process
	group is set by the child.  This will further isolate it from its
	process environment (and in fact will move xvile into the background
	if started from the shell).

	The "new-process-group" command has no effect in non-X11 versions
	of vile.


	X Resources
	-----------

	font		Font to use.

	geometry	Window dimensions in characters.

	charClass	Character classes for multiple click selections.
			The format is identical to that of xterm(1).

	multiClickTime	How long between clicks (in milliseconds) to
			be accepted as a multi-click.

	foreground
	background	Foreground/Background color of the main xvile text
			area.

	cursor.foreground
	cursor.background   Foreground/Background color of the cursor.
			By default the cursor location is indicated by
			inverting the foreground and background colors of
			the cell the cursor is over.  Thus the color of the
			cursor will vary depending upon location.  Use of
			these subresources will cause the cursor to
			maintain constant coloration of the user's
			choosing, and may make it easier to see when it
			appears in a "highlighted" or "selected" area of
			text.

	modeline.focusForeground
	modeline.focusBackground   Foreground/Background color of the mode
			line corresponding to the window with focus, i.e.
			the "current" window.

	modeline.foreground
	modeline.background   Foreground/Background color of mode lines
			corresponding to windows without the keyboard
			focus.  modeline.background is also used for the
			scrollbar borders and resize grips.

	focusFollowsMouse  If true, the "current" window is the window
			inhabited by the mouse; no clicking is necessary
			to change windows.

	scrollbarOnLeft Either true or false; control the placement of
			the scrollbars.  By default, scrollbars are placed
			on the right.

	scrollbarWidth	An integer indicating the width of the scrollbar.

	scrollbar.foreground
	scrollbar.background  Foreground/Background color of the slider or
			one of the colors of the slider if a stippled
			pixmap is used.  To force the slider to be only the
			foreground color, you should set sliderIsSolid to
			true.  (X toolkit version only)

	scrollbar.sliderIsSolid  If false, indicates that the stippled
			pixmap should be used to simulate grey.  This will
			be best on monochrome displays.  True works better
			for color displays.  True indicates the slider will
			be displayed in the foreground color, shaded to
			look three-dimensional, if possible.  (X toolkit
			version only)

	scrollRepeatTimeout  Amount of time in milliseconds to wait initially
			before repeating scroll when button one or three are
			held down. (X toolkit version only).

	scrollRepeatInterval  Amount of time to wait between repeating
			subsequent scrolls.   This parameter is also used
			for controlling the speed at which selections are
			scrolled.

	selection.foreground
	selection.background Foreground/Background color of the selection
			regions.  "foreground" is the color that
			the text is displayed in.

	persistentSelections  If true (the default), highlighting of the
			selection will persist even when button one is
			pressed to set the cursor position.  A false value
			will behave more like other X applications in which
			display of the selection is lost as soon as button
			one is pressed.

	blinkInterval	An integer indicating the time in milliseconds to wait
			before blinking the cursor.  A positive value will
			cause the cursor to always blink.  Setting
			blinkInterval to zero will cause the cursor to never
			blink which may be useful on some display servers
			connected to very slow networks.  The disadvantage
			of setting it to zero is that it is sometimes hard
			to tell where the cursor is when situated at the
			boundary of a highlighted region.  A negative value
			(which is the default) will cause the cursor to
			blink only when situated in a highlighted region
			such as a selection.  This will make the cursor
			visible no matter where it is.

	color.fcolor1,
	color.bcolor1, ...,
	color.fcolor15,
	color.bcolor15
			When doing text attribution with the
			"attribute-cntl_a-sequences-til" command (bound to
			^A-A), the attribute may be of the form "Cn", where
			'n' is a hex digit.  This digit picks one of the 16
			fcolor/bcolor pairs set up in the color
			subresource.  For example, if the buffer contained
			the text:
				^A6C3:foobar
			then after the ^A-A command was applied, the leading
			"^A3C3:" would be gone, and the word "foobar" would
			appear in the foreground and background colors
			specified by color.fcolor3 and color.bcolor3.  Either
			of the pair can be left unspecified, and will default
			to the natural foreground or background color of
			normal text.


	Sample .Xdefault entries
	------------------------

	You may or may not want to use the following as a starting point
	for the "XVile" section of your .Xdefaults or .Xresources file.  If
	you have a monochrome display server, you will probably not want
	to use any of the color specifications.  You may, however, wish
	to set up a blinking cursor, using "blinkInterval"  (see above).

	XVile*font: -*-courier-medium-r-normal-*-*-*-75-75-m-70-iso8859-*
	XVile*geometry:	80x54
	XVile.background: darkslategrey
	XVile.foreground: honeydew
	XVile.scrollbar.foreground: firebrick2
	XVile.scrollbar.sliderIsSolid: true
	XVile.selection.background: aquamarine4
	XVile.selection.foreground: honeydew
	XVile.cursor.background: yellow
	XVile.cursor.foreground: darkslategrey
	XVile.modeline.Background: steelblue
	XVile.modeline.foreground: darkslategrey
	XVile.modeline.focusForeground: yellow

	Fonts
	-----

	To change the font on the fly, use the ':setv' command to set the
	$font variable, with ":setv $font <fontname>".

	At present, only xvile is capable of displaying bold and italic (or
	underline) text associated with attributes.  It is anticipated that
	other versions of vile will catch up to the best of their ability.
	Users of xvile will find that the italic font in particular is not
	always available with the font that they've chosen (or have had
	chosen for them).  If an italic font is unavailable, xvile will
	underline text which is meant to be italic.  The program xfontsel is
	quite useful for determining which fonts are available on your
	display server and whether there are corresponding bold and/or
	italic fonts available.

	Here are some tips on using xfontsel to find an appropriate font.

		1) Set rgstry (registry) to iso8859
		2) Set spc (spacing) to either "c" (cell font) or "m"
		   (monospaced font).  You will be more likely to find a
		   font which will work as italic if you choose a
		   monospaced font, however.  You definitely do not want
		   a proportional font.
		3) Now pull down the slant menu.  Select either "i"
		   (italic) or "o" (oblique).  If neither of these are
		   available, go back to step 2 and choose a different
		   spacing.
		4) Set avgWdth (average width) next. If you divide the
		   value you've chosen by ten, this will be width of a
		   glyph in the font in pixels.
		5) Set wght (weight) to medium.  If you have a hard time
		   seeing the characters, you might want to choose bold,
		   but xvile will not be able to use the bold font for
		   displaying bold text.  It will be forced to overwrite
		   text that it wants to be bold with the text shifted by
		   one pixel.  This works fairly well for larger fonts.
		6) Set fmly (family) to a value according to personal taste.
		   By this step, you might not have any choice on the matter
		   anyway.
		7) If only one font is available at this point, the other
		   fields don't matter that much.  Otherwise set these
		   according to taste.
		8) Go back to the slant menu and change either the "i" or
		   "o" to "r".

		This will be the font to use.  xvile will be attempt to get
		the italic font when needed by substituting either "o" or
		"i" for the "r".

	If the above seems too tedious, you can just try the following font
	which (on many display servers) is pretty close to the size of the
	default font that xvile will start up with.

		-*-courier-medium-r-*-*-*-*-*-*-*-70-*-*

	You can try it out by issuing the appropriate "set font" command
	from xvile.  For longer term use, you will probably want to put it
	in your .Xdefaults file.  It will look something like this:

		XVile*font: -*-courier-medium-r-*-*-*-*-*-*-*-70-*-*

	You may also set the font from your .vilerc file.  This is not
	recommended, however, as you lose the ability to choose a different
	font from the command line or resource file.  It may also cause the
	xvile window to be unnecessarily resized during initialization.




DOS specifics
-------------

	The .vilerc file is called vile.rc under DOS.

	vile should leave your screen in the mode you're in when you
	enter it, unless you explicitly change it to a different mode with
	a "set sres=" line in your vile.rc, or if you use a command line
	option to change it.  Command line options consist of a dash
	followed by one of the following selectors (these are the same
	values that can be assigned to "sres"):
	    "default",
	    "2",     "25",    "80x25",
	    "4",     "43",    "80x43",
	    "5",     "50",    "80x50",
	    "80x14", "80x28",
	    "40x12", "40x21", "40x25", "40x28", "40x50",

	[ Currently, under DOS, not all modes may work, as a result of
	  the screen library being used... (in version 5.5).  More may
	  work under OS/2. ]

	If you shell out in 50 line mode, make sure you are in 50 line mode
	before you exit the dos shell, otherwise you end up with a 50 line
	edit window with only the top 25 displayed.

	The vile.rc file can be located in the same directory as your
	binary executable, since vile searches the PATH for this file.

	All file globbing, including from the command line, is done using
	UNIX shell-style wild-carding conventions.

	The expansion of the ':' character in user input, which normally
	expands to the "word under the cursor", is suppressed for DOS, due
	to the conflict with the drive-specifier syntax (e.g. "c:\foo").

	In any version of vile there is a command, "set-dos-mode", which
	will set the "dos" mode, and strip all carriage-return ('^M')
	characters from the buffer so you don't end up with two of them per
	line.  If you give the command an argument (e.g.  "1:set-dos-mode")
	it will strip CRs but leave you in non-DOS mode.

	If you wish to change the screen colors which correspond to vile's
	internal notion of black, red, green, yellow, blue, magenta, cyan,
	and white, put a line in your vile.rc which resets the "palette"
	variable.  By default its value is "0 4 2 14 1 5 3 7", which
	associates each of the above colors with the appropriate PC color
	attribute.  The palette values are masked with 7 before being used
	as background colors, to prevent blinking characters.


Differences from vi
-------------------

	Of course, this really isn't vi.  Some of the following differences
	deserve changing, others do not.

	The parser for the ':' commands is not very vi-like.  For instance,
	":e" will prompt you for a file name.  Most commands remember their
	last argument, and will present it as the default reply to their
	prompt.

	The backspace, line kill, word kill, job control, etc. characters
	are not rebindable.  They are, however, read from the tty settings
	on startup.

	There is no expansion of ! in filenames.  It is expanded in shell
	escapes, so the command ":!!" does rerun the previous shell command.
	Occurrences of '#' and '%' are recognized and expanded to the
	previous or current filename.

	Paragraph and section boundaries, for the {, }, [, and ] commands
	are configurable, but may not exactly match those in vi.  They are
	expressed via regular expressions.  The default regular expressions
	are quite complex, to support the traditional nroff and troff
	boundaries.  If you are just editing code, you may want to replace
	them:

		; set paragraph and section r.e.s for speed on C/C++/perl code.
		set paragraphs=^$
		set sections=^[{^L]

	There is no special lisp support.  But then, when was the last time
	you heard of a lisp programmer that used vi?

	Of course, ex and open mode aren't there.  (Too bad.  I'd love
	to have a companion editor called "exile".)

	Most, but not all, of the word-motion-with-operator and end-of-line
	anomalies have been recreated.  One missing anomaly: In vile, "dw"
	on the last word of a line ending in whitespace deletes the
	trailing whitespace.  vi does not delete the whitespace.

	In the real vi, the '_' command is a little-used motion command,
	which moves the cursor to the start of the Nth next line, where N
	is the argument given, less 1.  So '2_' takes you to the start of
	the next line.  Primarily intended for use in an operator context,
	as in "2d_", it is always exactly equivalent in those cases to
	"stuttering" the operator, as in "2dd".  Most people know about and
	use the stuttered form, so in vile, the '_' command is used by
	default for buffer history.  If the regular vi behavior is desired,
	put the following in the .vilerc file:

		bind-key whole-lines _

Sample .vilerc
--------------

	Here's a sample .vilerc, to help get you started with the
	syntax and style of vile macros:

	set autoindent
	set fillcol 75
	set cmode
	set c-tabstop 4

	; sitting on a brace, run the C code block through indent
	1 store-macro
		write-file
		filter-til goto-matching-fence "indent -st"
	~endm


	; format the current paragraph
	2 store-macro
		previous-paragraph
		filter-til next-paragraph "/usr/ucb/fmt"
	~endm

	; put 'fprintf(stderr,"\n");" into the file, and
	; position the cursor to add to the string
	3 store-macro
		~force next-line
		beginning-of-line
		insert-string "fprintf(stderr, \"\\n\");\n"
		; six back, because it counts the newline
		6 backward-character
		insert-chars
	~endm

	; insert '> ' in front of every line from here til the end
	; (this works because without argument, the default action
	; for "goto-line" is to go to the end of file.
	4 store-macro
		substitute-til goto-line "^" "> "
	~endm

	; spelling keystroke: write the buffer, invoke ispell, and force
	; 	it to be read back in.
	2 store-macro
		write-file
		; suppress "press return" with "1" argument to shell-command
		1 shell-command &cat "ispell " $cfilname
		replace-with-file $cfilname
	~endm
	bind-key execute-macro-2 =



	; the next three give more mnemonic window commands
	bind-key next-window ^N
	bind-key previous-window ^P
	bind-key split-current-window ^T

	bind-key execute-macro-1 ^A-C
	bind-key execute-macro-2 ^A-F
	bind-key execute-macro-3 ^A-K
	bind-key execute-macro-4 ^A-M

Notes on TERM types and Scrolling
---------------------------------

	vile will determine the window size in one of three ways: first it
	will ask the tty driver (using a TIOCGWINSZ ioctl call under UNIX).
	Failing that, it will use the LINES and COLUMNS environment
	variables.  As a last resort it will use the size specified in the
	TERMCAP entry corresponding to the TERM variable.  In addition,
	vile will attempt to support the SIGWINCH signal, which allows it
	to track changes to the size of the window in which it is running.

	If scrolling is really slow, or really ugly (the status line hops
	around a lot), and you're using a vt102 or compatible terminal that
	you think should be able to scroll okay, then the problem is almost
	certainly your termcap entry, which probably doesn't describe
	scrolling regions adequately.  Most standard termcap entries are
	insufficient.  The standard "xterm" entry on many systems falls
	into this category, and vile contains code that, as a special case,
	will augment an "xterm" entry with the codes needed for scrolling
	regions.

	In any case, here's a termcap entry that should work:

        dy|vt102|vt-102|dec vt102:\
            :do=^J:co#80:li#24:cl=50\E[;H\E[2J:\
            :le=^H:bs:cm=5\E[%i%d;%dH:nd=2\E[C:up=2\E[A:\
            :ce=3\E[K:cd=50\E[J:so=2\E[7m:se=2\E[m:us=2\E[4m:ue=2\E[m:\
            :md=2\E[1m:mr=2\E[7m:mb=2\E[5m:me=2\E[m:is=\E[1;24r\E[24;1H:\
            :rs=\E>\E[?3l\E[?4l\E[?5l\E[?7h\E[?8h:ks=\E[?1h\E=:ke=\E[?1l\E>:\
            :ku=\EOA:kd=\EOB:kr=\EOC:kl=\EOD:kb=^H:\
            :ho=\E[H:k1=\EOP:k2=\EOQ:k3=\EOR:k4=\EOS:pt:sr=5\EM:vt#3:\
            :sc=\E7:rc=\E8:cs=\E[%i%d;%dr:vs=\E[?7l:ve=\E[?7h:

	The crucial entries are cs and sr -- without both of them,
	vile will attempt to use dl and al, and will scroll by
	deleting and inserting a block of lines, giving the ugly
	behavior you're probably seeing.  If you define PRETTIER_SCROLL
	when building vile, it will alternately delete and insert lines,
	instead of deleting them all and then inserting them all.  This
	makes it look a _little_ better, but it's slower.

	( Here is the terminfo entry equivalent to the above termcap entry:

	vt102|vt-102|dec vt102,
		xon,
		cols#80, lines#24, vt#3,
		bel=^G, blink=\E[5m$<2>, bold=\E[1m$<2>,
		clear=\E[;H\E[2J$<50>, cnorm=\E[?7h, cr=\r,
		csr=\E[%i%p1%d;%p2%dr, cub1=\b, cud1=\n,
		cuf1=\E[C$<2>, cup=\E[%i%p1%d;%p2%dH$<5>,
		cuu1=\E[A$<2>, cvvis=\E[?7l, ed=\E[J$<50>,
		el=\E[K$<3>, home=\E[H, ht=\t, ind=\n,
		is2=\E[1;24r\E[24;1H, kbs=\b, kcub1=\EOD, kcud1=\EOB,
		kcuf1=\EOC, kcuu1=\EOA, kf1=\EOP, kf2=\EOQ, kf3=\EOR,
		kf4=\EOS, rc=\E8, rev=\E[7m$<2>, ri=\EM$<5>,
		rmkx=\E[?1l\E>, rmso=\E[m$<2>, rmul=\E[m$<2>,
		rs2=\E>\E[?3l\E[?4l\E[?5l\E[?7h\E[?8h, sc=\E7,
		sgr0=\E[m$<2>, smkx=\E[?1h\E=, smso=\E[7m$<2>,
		smul=\E[4m$<2>,
	)

Credits
-------

	This code has been written by a _lot_ of people, with help from a
	lot more sending in bug reports, fixes, and suggestions.  But bug
	reports should be sent to Paul Fox, pgf@foxharp.boston.ma.us, since
	I'm (still) (principally) responsible for this thing.  My
	co-authors are Tom Dickey (dickey@clark.net) and Kevin Buettner
	(kev@primenet.com).

	Names appearing within comments in the micro-Emacs source code are:
	Dave Conroy, Daniel Lawrence, John Gamble, Roger Ove, Dana Hoggatt,
	Jon Reid, Steve Wilhite, George Jones, Adam Fritz, D.R.Banks, Bob
	McNamara, and Brian Straight.

	Tom Dickey has contributed many code improvements and features, and
	has stabilized vile on both VMS and DOS.  Kevin Buettner has
	contributed lots of changes for X11 Toolkit support, as well as the
	bulk of the selection and video attribute mechanisms, and the bulk
	of the :map command.  Rick Sladkey has done great stuff making vile
	work correctly in Win32 environments, something I might not have
	done for a long time.  Some of the "ex" code is by Steve Kirkendall,
	author of the vi work-alike "elvis".  The regular expression code
	and documentation is by Henry Spencer.  The sample .vilerc was
	created by Dave Lemke; he also contributed code for new features,
	including the original native X support.  Eric Krohn has done some
	excellent testing and enhancement.  The implementation of
	rectangles and their operations was inspired by code from the
	'notgnu' editor, by Julie Melbin.  Patches to support OS/2 and
	Windows/NT came from Charles Moschel and Joe Greer, respectively.
	Clark Morgan and Greg McFarlane seem to run full regression tests
	on each new release, and always seem to find something to report.
	The reference.doc file supplied with Bram Moolenaar's excellent Vim
	editor was useful in unravelling some of the less obvious parts of
	:map functionality.  Thanks to Jukka Keto for contributing the
	c-filt.c code.

	The initial changes to create vile from micro-Emacs were all done
	by Paul Fox, who can be reached at home at pgf@foxharp.boston.ma.us.
	(By the way, he is not the Paul D. Fox that wrote the Crisp editor.)

Copyright 1995 by Paul Fox, Tom Dickey, and Kevin Buettner
-----------------------------------------------------------
 $Header: /usr/build/VCS/pgf-vile/RCS/vile.hlp,v 1.274 1995/11/21 14:21:07 pgf Exp $
